// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'dart:ui';

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:collection';
import 'dart:convert'
    show
        ascii,
        base64,
        Base64Codec,
        Encoding,
        latin1,
        StringConversionSink,
        utf8;
import 'dart:math' show Random;
import 'dart:typed_data' show Uint8List;

part '../proxy/proxy__dart_core.dart';

const libraryMirror = m.LibraryMirror(
  'dart:core',
  {
    ...globalSetters,
    'deprecated': _deprecated$,
    'override': _override$,
    'pragma.': _pragma__$,
    'BigInt.zero': _BigInt_zero$,
    'BigInt.one': _BigInt_one$,
    'BigInt.two': _BigInt_two$,
    'BigInt.from': _BigInt_from_$,
    'BigInt.parse': _BigInt_parse$,
    'BigInt.tryParse': _BigInt_tryParse$,
    'bool.fromEnvironment': _bool_fromEnvironment_$,
    'bool.hasEnvironment': _bool_hasEnvironment_$,
    'bool.parse': _bool_parse$,
    'bool.tryParse': _bool_tryParse$,
    'Comparable.compare': _Comparable_compare$,
    'DateTime.monday': _DateTime_monday$,
    'DateTime.tuesday': _DateTime_tuesday$,
    'DateTime.wednesday': _DateTime_wednesday$,
    'DateTime.thursday': _DateTime_thursday$,
    'DateTime.friday': _DateTime_friday$,
    'DateTime.saturday': _DateTime_saturday$,
    'DateTime.sunday': _DateTime_sunday$,
    'DateTime.daysPerWeek': _DateTime_daysPerWeek$,
    'DateTime.january': _DateTime_january$,
    'DateTime.february': _DateTime_february$,
    'DateTime.march': _DateTime_march$,
    'DateTime.april': _DateTime_april$,
    'DateTime.may': _DateTime_may$,
    'DateTime.june': _DateTime_june$,
    'DateTime.july': _DateTime_july$,
    'DateTime.august': _DateTime_august$,
    'DateTime.september': _DateTime_september$,
    'DateTime.october': _DateTime_october$,
    'DateTime.november': _DateTime_november$,
    'DateTime.december': _DateTime_december$,
    'DateTime.monthsPerYear': _DateTime_monthsPerYear$,
    'DateTime.': _DateTime__$,
    'DateTime.utc': _DateTime_utc_$,
    'DateTime.now': _DateTime_now_$,
    'DateTime.timestamp': _DateTime_timestamp_$,
    'DateTime.fromMillisecondsSinceEpoch':
        _DateTime_fromMillisecondsSinceEpoch_$,
    'DateTime.fromMicrosecondsSinceEpoch':
        _DateTime_fromMicrosecondsSinceEpoch_$,
    'DateTime.parse': _DateTime_parse$,
    'DateTime.tryParse': _DateTime_tryParse$,
    'double.nan': _double_nan$,
    'double.infinity': _double_infinity$,
    'double.negativeInfinity': _double_negativeInfinity$,
    'double.minPositive': _double_minPositive$,
    'double.maxFinite': _double_maxFinite$,
    'double.parse': _double_parse$,
    'double.tryParse': _double_tryParse$,
    'Duration.microsecondsPerMillisecond':
        _Duration_microsecondsPerMillisecond$,
    'Duration.millisecondsPerSecond': _Duration_millisecondsPerSecond$,
    'Duration.secondsPerMinute': _Duration_secondsPerMinute$,
    'Duration.minutesPerHour': _Duration_minutesPerHour$,
    'Duration.hoursPerDay': _Duration_hoursPerDay$,
    'Duration.microsecondsPerSecond': _Duration_microsecondsPerSecond$,
    'Duration.microsecondsPerMinute': _Duration_microsecondsPerMinute$,
    'Duration.microsecondsPerHour': _Duration_microsecondsPerHour$,
    'Duration.microsecondsPerDay': _Duration_microsecondsPerDay$,
    'Duration.millisecondsPerMinute': _Duration_millisecondsPerMinute$,
    'Duration.millisecondsPerHour': _Duration_millisecondsPerHour$,
    'Duration.millisecondsPerDay': _Duration_millisecondsPerDay$,
    'Duration.secondsPerHour': _Duration_secondsPerHour$,
    'Duration.secondsPerDay': _Duration_secondsPerDay$,
    'Duration.minutesPerDay': _Duration_minutesPerDay$,
    'Duration.zero': _Duration_zero$,
    'Duration.': _Duration__$,
    'Enum.compareByIndex': _Enum_compareByIndex$,
    'Enum.compareByName': _Enum_compareByName$,
    'Error.': _Error__$,
    'Error.safeToString': _Error_safeToString$,
    'Error.throwWithStackTrace': _Error_throwWithStackTrace$,
    'AssertionError.': _AssertionError__$,
    'TypeError.': _TypeError__$,
    'ArgumentError.': _ArgumentError__$,
    'ArgumentError.value': _ArgumentError_value_$,
    'ArgumentError.notNull': _ArgumentError_notNull_$,
    'ArgumentError.checkNotNull': _ArgumentError_checkNotNull$,
    'RangeError.': _RangeError__$,
    'RangeError.value': _RangeError_value_$,
    'RangeError.range': _RangeError_range_$,
    'RangeError.index': _RangeError_index_$,
    'RangeError.checkValueInInterval': _RangeError_checkValueInInterval$,
    'RangeError.checkValidIndex': _RangeError_checkValidIndex$,
    'RangeError.checkValidRange': _RangeError_checkValidRange$,
    'RangeError.checkNotNegative': _RangeError_checkNotNegative$,
    'IndexError.withLength': _IndexError_withLength_$,
    'IndexError.check': _IndexError_check$,
    'NoSuchMethodError.withInvocation': _NoSuchMethodError_withInvocation_$,
    'UnsupportedError.': _UnsupportedError__$,
    'UnimplementedError.': _UnimplementedError__$,
    'StateError.': _StateError__$,
    'ConcurrentModificationError.': _ConcurrentModificationError__$,
    'OutOfMemoryError.': _OutOfMemoryError__$,
    'StackOverflowError.': _StackOverflowError__$,
    'Exception.': _Exception__$,
    'FormatException.': _FormatException__$,
    'Function.apply': _Function_apply$,
    'identical': _identical$,
    'identityHashCode': _identityHashCode$,
    'int.fromEnvironment': _int_fromEnvironment_$,
    'int.parse': _int_parse$,
    'int.tryParse': _int_tryParse$,
    'Invocation.method': _Invocation_method_$,
    'Invocation.genericMethod': _Invocation_genericMethod_$,
    'Invocation.getter': _Invocation_getter_$,
    'Invocation.setter': _Invocation_setter_$,
    'Iterable.generate': _Iterable_generate_$,
    'Iterable.empty': _Iterable_empty_$,
    'Iterable.castFrom': _Iterable_castFrom$,
    'Iterable.iterableToShortString': _Iterable_iterableToShortString$,
    'Iterable.iterableToFullString': _Iterable_iterableToFullString$,
    'List.filled': _List_filled_$,
    'List.empty': _List_empty_$,
    'List.from': _List_from_$,
    'List.of': _List_of_$,
    'List.generate': _List_generate_$,
    'List.unmodifiable': _List_unmodifiable_$,
    'List.castFrom': _List_castFrom$,
    'List.copyRange': _List_copyRange$,
    'List.writeIterable': _List_writeIterable$,
    'Map.': _Map__$,
    'Map.from': _Map_from_$,
    'Map.of': _Map_of_$,
    'Map.unmodifiable': _Map_unmodifiable_$,
    'Map.identity': _Map_identity_$,
    'Map.fromIterable': _Map_fromIterable_$,
    'Map.fromIterables': _Map_fromIterables_$,
    'Map.fromEntries': _Map_fromEntries_$,
    'Map.castFrom': _Map_castFrom$,
    'MapEntry.': _MapEntry__$,
    'num.tryParse': _num_tryParse$,
    'Object.': _Object__$,
    'Object.hash': _Object_hash$,
    'Object.hashAll': _Object_hashAll$,
    'Object.hashAllUnordered': _Object_hashAllUnordered$,
    'print': _print$,
    'RegExp.': _RegExp__$,
    'RegExp.escape': _RegExp_escape$,
    'Set.': _Set__$,
    'Set.identity': _Set_identity_$,
    'Set.from': _Set_from_$,
    'Set.of': _Set_of_$,
    'Set.unmodifiable': _Set_unmodifiable_$,
    'StackTrace.empty': _StackTrace_empty$,
    'StackTrace.current': _StackTrace_current$,
    'StackTrace.fromString': _StackTrace_fromString_$,
    'Stopwatch.': _Stopwatch__$,
    'String.fromCharCodes': _String_fromCharCodes_$,
    'String.fromCharCode': _String_fromCharCode_$,
    'String.fromEnvironment': _String_fromEnvironment_$,
    'Runes.': _Runes__$,
    'RuneIterator.': _RuneIterator__$,
    'RuneIterator.at': _RuneIterator_at_$,
    'StringBuffer.': _StringBuffer__$,
    'Symbol.unaryMinus': _Symbol_unaryMinus$,
    'Symbol.empty': _Symbol_empty$,
    'Symbol.': _Symbol__$,
    'Uri.base': _Uri_base$,
    'Uri.': _Uri__$,
    'Uri.http': _Uri_http_$,
    'Uri.https': _Uri_https_$,
    'Uri.file': _Uri_file_$,
    'Uri.directory': _Uri_directory_$,
    'Uri.dataFromString': _Uri_dataFromString_$,
    'Uri.dataFromBytes': _Uri_dataFromBytes_$,
    'Uri.parse': _Uri_parse$,
    'Uri.tryParse': _Uri_tryParse$,
    'Uri.encodeComponent': _Uri_encodeComponent$,
    'Uri.encodeQueryComponent': _Uri_encodeQueryComponent$,
    'Uri.decodeComponent': _Uri_decodeComponent$,
    'Uri.decodeQueryComponent': _Uri_decodeQueryComponent$,
    'Uri.encodeFull': _Uri_encodeFull$,
    'Uri.decodeFull': _Uri_decodeFull$,
    'Uri.splitQueryString': _Uri_splitQueryString$,
    'Uri.parseIPv4Address': _Uri_parseIPv4Address$,
    'Uri.parseIPv6Address': _Uri_parseIPv6Address$,
    'UriData.fromString': _UriData_fromString_$,
    'UriData.fromBytes': _UriData_fromBytes_$,
    'UriData.fromUri': _UriData_fromUri_$,
    'UriData.parse': _UriData_parse$,
    'Expando.': _Expando__$,
    'WeakReference.': _WeakReference__$,
    'Finalizer.': _Finalizer__$,
  },
  {},
  {
    'Deprecated': m.ClassMirror(
      'Deprecated',
      {
        '#as': Deprecated_as$,
        '#is': Deprecated_is$,
        'message': _Deprecated_message$,
        'toString': _Deprecated_toString$,
      },
      {},
    ),
    'pragma': m.ClassMirror(
      'pragma',
      {
        '#as': pragma_as$,
        '#is': pragma_is$,
        'name': _pragma_name$,
        'options': _pragma_options$,
      },
      {},
    ),
    'BigInt': m.ClassMirror(
      'BigInt',
      {
        '#as': BigInt_as$,
        '#is': BigInt_is$,
        'bitLength': _BigInt_bitLength$,
        'sign': _BigInt_sign$,
        'isEven': _BigInt_isEven$,
        'isOdd': _BigInt_isOdd$,
        'isNegative': _BigInt_isNegative$,
        'isValidInt': _BigInt_isValidInt$,
        'abs': _BigInt_abs$,
        'unary-': _BigInt_unary_minus$$,
        '+': _BigInt_plus$$,
        '-': _BigInt_minus$$,
        '*': _BigInt_times$$,
        '/': _BigInt_over$$,
        '~/': _BigInt_division$$,
        '%': _BigInt_surplus$$,
        'remainder': _BigInt_remainder$,
        '<<': _BigInt_left_move$$,
        '>>': _BigInt_right_move$$,
        '&': _BigInt_bit_and$$,
        '|': _BigInt_bit_or$$,
        '^': _BigInt_bit_xor$$,
        '~': _BigInt_bit_non$$,
        '<': _BigInt_low$$,
        '<=': _BigInt_low_eq$$,
        '>': _BigInt_more$$,
        '>=': _BigInt_more_eq$$,
        'compareTo': _BigInt_compareTo$,
        'pow': _BigInt_pow$,
        'modPow': _BigInt_modPow$,
        'modInverse': _BigInt_modInverse$,
        'gcd': _BigInt_gcd$,
        'toUnsigned': _BigInt_toUnsigned$,
        'toSigned': _BigInt_toSigned$,
        'toInt': _BigInt_toInt$,
        'toDouble': _BigInt_toDouble$,
        'toString': _BigInt_toString$,
        'toRadixString': _BigInt_toRadixString$,
      },
      {},
    ),
    'bool': m.ClassMirror(
      'bool',
      {
        '#as': bool_as$,
        '#is': bool_is$,
        'hashCode': _bool_hashCode$,
        '&': _bool_bit_and$$,
        '|': _bool_bit_or$$,
        '^': _bool_bit_xor$$,
        'toString': _bool_toString$,
      },
      {},
    ),
    'Comparable': m.ClassMirror(
      'Comparable',
      {
        '#as': Comparable_as$,
        '#is': Comparable_is$,
        'compareTo': _Comparable_compareTo$,
      },
      {},
    ),
    'DateTime': m.ClassMirror(
      'DateTime',
      {
        '#as': DateTime_as$,
        '#is': DateTime_is$,
        'isUtc': _DateTime_isUtc$,
        'hashCode': _DateTime_hashCode$,
        'millisecondsSinceEpoch': _DateTime_millisecondsSinceEpoch$,
        'microsecondsSinceEpoch': _DateTime_microsecondsSinceEpoch$,
        'timeZoneName': _DateTime_timeZoneName$,
        'timeZoneOffset': _DateTime_timeZoneOffset$,
        'year': _DateTime_year$,
        'month': _DateTime_month$,
        'day': _DateTime_day$,
        'hour': _DateTime_hour$,
        'minute': _DateTime_minute$,
        'second': _DateTime_second$,
        'millisecond': _DateTime_millisecond$,
        'microsecond': _DateTime_microsecond$,
        'weekday': _DateTime_weekday$,
        '==': _DateTime_eq$$,
        'isBefore': _DateTime_isBefore$,
        'isAfter': _DateTime_isAfter$,
        'isAtSameMomentAs': _DateTime_isAtSameMomentAs$,
        'compareTo': _DateTime_compareTo$,
        'toLocal': _DateTime_toLocal$,
        'toUtc': _DateTime_toUtc$,
        'toString': _DateTime_toString$,
        'toIso8601String': _DateTime_toIso8601String$,
        'add': _DateTime_add$,
        'subtract': _DateTime_subtract$,
        'difference': _DateTime_difference$,
      },
      {},
    ),
    'double': m.ClassMirror(
      'double',
      {
        '#as': double_as$,
        '#is': double_is$,
        'sign': _double_sign$,
        'remainder': _double_remainder$,
        '+': _double_plus$$,
        '-': _double_minus$$,
        '*': _double_times$$,
        '%': _double_surplus$$,
        '/': _double_over$$,
        '~/': _double_division$$,
        'unary-': _double_unary_minus$$,
        'abs': _double_abs$,
        'round': _double_round$,
        'floor': _double_floor$,
        'ceil': _double_ceil$,
        'truncate': _double_truncate$,
        'roundToDouble': _double_roundToDouble$,
        'floorToDouble': _double_floorToDouble$,
        'ceilToDouble': _double_ceilToDouble$,
        'truncateToDouble': _double_truncateToDouble$,
        'toString': _double_toString$,
      },
      {},
    ),
    'Duration': m.ClassMirror(
      'Duration',
      {
        '#as': Duration_as$,
        '#is': Duration_is$,
        'inDays': _Duration_inDays$,
        'inHours': _Duration_inHours$,
        'inMinutes': _Duration_inMinutes$,
        'inSeconds': _Duration_inSeconds$,
        'inMilliseconds': _Duration_inMilliseconds$,
        'inMicroseconds': _Duration_inMicroseconds$,
        'hashCode': _Duration_hashCode$,
        'isNegative': _Duration_isNegative$,
        '+': _Duration_plus$$,
        '-': _Duration_minus$$,
        '*': _Duration_times$$,
        '~/': _Duration_division$$,
        '<': _Duration_low$$,
        '>': _Duration_more$$,
        '<=': _Duration_low_eq$$,
        '>=': _Duration_more_eq$$,
        '==': _Duration_eq$$,
        'compareTo': _Duration_compareTo$,
        'toString': _Duration_toString$,
        'abs': _Duration_abs$,
        'unary-': _Duration_unary_minus$$,
      },
      {},
    ),
    'Enum': m.ClassMirror(
      'Enum',
      {
        '#as': Enum_as$,
        '#is': Enum_is$,
        'index': _Enum_index$,
      },
      {},
    ),
    'Error': m.ClassMirror(
      'Error',
      {
        '#as': Error_as$,
        '#is': Error_is$,
        'stackTrace': _Error_stackTrace$,
      },
      {},
    ),
    'AssertionError': m.ClassMirror(
      'AssertionError',
      {
        '#as': AssertionError_as$,
        '#is': AssertionError_is$,
        'message': _AssertionError_message$,
        'toString': _AssertionError_toString$,
      },
      {},
    ),
    'TypeError': m.ClassMirror(
      'TypeError',
      {
        '#as': TypeError_as$,
        '#is': TypeError_is$,
      },
      {},
    ),
    'ArgumentError': m.ClassMirror(
      'ArgumentError',
      {
        '#as': ArgumentError_as$,
        '#is': ArgumentError_is$,
        'invalidValue': _ArgumentError_invalidValue$,
        'name': _ArgumentError_name$,
        'message': _ArgumentError_message$,
        'toString': _ArgumentError_toString$,
      },
      {},
    ),
    'RangeError': m.ClassMirror(
      'RangeError',
      {
        '#as': RangeError_as$,
        '#is': RangeError_is$,
        'start': _RangeError_start$,
        'end': _RangeError_end$,
        'invalidValue': _RangeError_invalidValue$,
      },
      {},
    ),
    'IndexError': m.ClassMirror(
      'IndexError',
      {
        '#as': IndexError_as$,
        '#is': IndexError_is$,
        'indexable': _IndexError_indexable$,
        'length': _IndexError_length$,
        'invalidValue': _IndexError_invalidValue$,
        'start': _IndexError_start$,
        'end': _IndexError_end$,
      },
      {},
    ),
    'NoSuchMethodError': m.ClassMirror(
      'NoSuchMethodError',
      {
        '#as': NoSuchMethodError_as$,
        '#is': NoSuchMethodError_is$,
        'toString': _NoSuchMethodError_toString$,
      },
      {},
    ),
    'UnsupportedError': m.ClassMirror(
      'UnsupportedError',
      {
        '#as': UnsupportedError_as$,
        '#is': UnsupportedError_is$,
        'message': _UnsupportedError_message$,
        'toString': _UnsupportedError_toString$,
      },
      {},
    ),
    'UnimplementedError': m.ClassMirror(
      'UnimplementedError',
      {
        '#as': UnimplementedError_as$,
        '#is': UnimplementedError_is$,
        'message': _UnimplementedError_message$,
        'toString': _UnimplementedError_toString$,
      },
      {},
    ),
    'StateError': m.ClassMirror(
      'StateError',
      {
        '#as': StateError_as$,
        '#is': StateError_is$,
        'message': _StateError_message$,
        'toString': _StateError_toString$,
      },
      {},
    ),
    'ConcurrentModificationError': m.ClassMirror(
      'ConcurrentModificationError',
      {
        '#as': ConcurrentModificationError_as$,
        '#is': ConcurrentModificationError_is$,
        'modifiedObject': _ConcurrentModificationError_modifiedObject$,
        'toString': _ConcurrentModificationError_toString$,
      },
      {},
    ),
    'OutOfMemoryError': m.ClassMirror(
      'OutOfMemoryError',
      {
        '#as': OutOfMemoryError_as$,
        '#is': OutOfMemoryError_is$,
        'stackTrace': _OutOfMemoryError_stackTrace$,
        'toString': _OutOfMemoryError_toString$,
      },
      {},
    ),
    'StackOverflowError': m.ClassMirror(
      'StackOverflowError',
      {
        '#as': StackOverflowError_as$,
        '#is': StackOverflowError_is$,
        'stackTrace': _StackOverflowError_stackTrace$,
        'toString': _StackOverflowError_toString$,
      },
      {},
    ),
    'Exception': m.ClassMirror(
      'Exception',
      {
        '#as': Exception_as$,
        '#is': Exception_is$,
      },
      {},
    ),
    'FormatException': m.ClassMirror(
      'FormatException',
      {
        '#as': FormatException_as$,
        '#is': FormatException_is$,
        'message': _FormatException_message$,
        'source': _FormatException_source$,
        'offset': _FormatException_offset$,
        'toString': _FormatException_toString$,
      },
      {},
    ),
    'Function': m.ClassMirror(
      'Function',
      {
        '#as': Function_as$,
        '#is': Function_is$,
        'hashCode': _Function_hashCode$,
        '==': _Function_eq$$,
      },
      {},
    ),
    'int': m.ClassMirror(
      'int',
      {
        '#as': int_as$,
        '#is': int_is$,
        'isEven': _int_isEven$,
        'isOdd': _int_isOdd$,
        'bitLength': _int_bitLength$,
        'sign': _int_sign$,
        '&': _int_bit_and$$,
        '|': _int_bit_or$$,
        '^': _int_bit_xor$$,
        '~': _int_bit_non$$,
        '<<': _int_left_move$$,
        '>>': _int_right_move$$,
        '>>>': _int_unsign_right_move$$,
        'modPow': _int_modPow$,
        'modInverse': _int_modInverse$,
        'gcd': _int_gcd$,
        'toUnsigned': _int_toUnsigned$,
        'toSigned': _int_toSigned$,
        'unary-': _int_unary_minus$$,
        'abs': _int_abs$,
        'round': _int_round$,
        'floor': _int_floor$,
        'ceil': _int_ceil$,
        'truncate': _int_truncate$,
        'roundToDouble': _int_roundToDouble$,
        'floorToDouble': _int_floorToDouble$,
        'ceilToDouble': _int_ceilToDouble$,
        'truncateToDouble': _int_truncateToDouble$,
        'toString': _int_toString$,
        'toRadixString': _int_toRadixString$,
      },
      {},
    ),
    'Invocation': m.ClassMirror(
      'Invocation',
      {
        '#as': Invocation_as$,
        '#is': Invocation_is$,
        'memberName': _Invocation_memberName$,
        'typeArguments': _Invocation_typeArguments$,
        'positionalArguments': _Invocation_positionalArguments$,
        'namedArguments': _Invocation_namedArguments$,
        'isMethod': _Invocation_isMethod$,
        'isGetter': _Invocation_isGetter$,
        'isSetter': _Invocation_isSetter$,
        'isAccessor': _Invocation_isAccessor$,
      },
      {},
    ),
    'Iterable': m.ClassMirror(
      'Iterable',
      {
        '#as': Iterable_as$,
        '#is': Iterable_is$,
        'iterator': _Iterable_iterator$,
        'length': _Iterable_length$,
        'isEmpty': _Iterable_isEmpty$,
        'isNotEmpty': _Iterable_isNotEmpty$,
        'first': _Iterable_first$,
        'last': _Iterable_last$,
        'single': _Iterable_single$,
        'cast': _Iterable_cast$,
        'followedBy': _Iterable_followedBy$,
        'map': _Iterable_map$,
        'where': _Iterable_where$,
        'whereType': _Iterable_whereType$,
        'expand': _Iterable_expand$,
        'contains': _Iterable_contains$,
        'forEach': _Iterable_forEach$,
        'reduce': _Iterable_reduce$,
        'fold': _Iterable_fold$,
        'every': _Iterable_every$,
        'join': _Iterable_join$,
        'any': _Iterable_any$,
        'toList': _Iterable_toList$,
        'toSet': _Iterable_toSet$,
        'take': _Iterable_take$,
        'takeWhile': _Iterable_takeWhile$,
        'skip': _Iterable_skip$,
        'skipWhile': _Iterable_skipWhile$,
        'firstWhere': _Iterable_firstWhere$,
        'lastWhere': _Iterable_lastWhere$,
        'singleWhere': _Iterable_singleWhere$,
        'elementAt': _Iterable_elementAt$,
        'toString': _Iterable_toString$,
      },
      {},
    ),
    'Iterator': m.ClassMirror(
      'Iterator',
      {
        '#as': Iterator_as$,
        '#is': Iterator_is$,
        'current': _Iterator_current$,
        'moveNext': _Iterator_moveNext$,
      },
      {},
    ),
    'List': m.ClassMirror(
      'List',
      {
        '#as': List_as$,
        '#is': List_is$,
        'length': _List_length$,
        'reversed': _List_reversed$,
        'cast': _List_cast$,
        '[]': _List_$index$$,
        '[]=': _List_$index_set$$,
        'add': _List_add$,
        'addAll': _List_addAll$,
        'sort': _List_sort$,
        'shuffle': _List_shuffle$,
        'indexOf': _List_indexOf$,
        'indexWhere': _List_indexWhere$,
        'lastIndexWhere': _List_lastIndexWhere$,
        'lastIndexOf': _List_lastIndexOf$,
        'clear': _List_clear$,
        'insert': _List_insert$,
        'insertAll': _List_insertAll$,
        'setAll': _List_setAll$,
        'remove': _List_remove$,
        'removeAt': _List_removeAt$,
        'removeLast': _List_removeLast$,
        'removeWhere': _List_removeWhere$,
        'retainWhere': _List_retainWhere$,
        '+': _List_plus$$,
        'sublist': _List_sublist$,
        'getRange': _List_getRange$,
        'setRange': _List_setRange$,
        'removeRange': _List_removeRange$,
        'fillRange': _List_fillRange$,
        'replaceRange': _List_replaceRange$,
        'asMap': _List_asMap$,
        '==': _List_eq$$,
      },
      {
        'first': _List_first_set$,
        'last': _List_last_set$,
        'length': _List_length_set$,
      },
    ),
    'Map': m.ClassMirror(
      'Map',
      {
        '#as': Map_as$,
        '#is': Map_is$,
        'entries': _Map_entries$,
        'keys': _Map_keys$,
        'values': _Map_values$,
        'length': _Map_length$,
        'isEmpty': _Map_isEmpty$,
        'isNotEmpty': _Map_isNotEmpty$,
        'cast': _Map_cast$,
        'containsValue': _Map_containsValue$,
        'containsKey': _Map_containsKey$,
        '[]': _Map_$index$$,
        '[]=': _Map_$index_set$$,
        'map': _Map_map$,
        'addEntries': _Map_addEntries$,
        'update': _Map_update$,
        'updateAll': _Map_updateAll$,
        'removeWhere': _Map_removeWhere$,
        'putIfAbsent': _Map_putIfAbsent$,
        'addAll': _Map_addAll$,
        'remove': _Map_remove$,
        'clear': _Map_clear$,
        'forEach': _Map_forEach$,
      },
      {},
    ),
    'MapEntry': m.ClassMirror(
      'MapEntry',
      {
        '#as': MapEntry_as$,
        '#is': MapEntry_is$,
        'key': _MapEntry_key$,
        'value': _MapEntry_value$,
        'toString': _MapEntry_toString$,
      },
      {},
    ),
    'Null': m.ClassMirror(
      'Null',
      {
        '#as': Null_as$,
        '#is': Null_is$,
        'hashCode': _Null_hashCode$,
        'toString': _Null_toString$,
      },
      {},
    ),
    'num': m.ClassMirror(
      'num',
      {
        '#as': num_as$,
        '#is': num_is$,
        'hashCode': _num_hashCode$,
        'isNaN': _num_isNaN$,
        'isNegative': _num_isNegative$,
        'isInfinite': _num_isInfinite$,
        'isFinite': _num_isFinite$,
        'sign': _num_sign$,
        '==': _num_eq$$,
        'compareTo': _num_compareTo$,
        '+': _num_plus$$,
        '-': _num_minus$$,
        '*': _num_times$$,
        '%': _num_surplus$$,
        '/': _num_over$$,
        '~/': _num_division$$,
        'unary-': _num_unary_minus$$,
        'remainder': _num_remainder$,
        '<': _num_low$$,
        '<=': _num_low_eq$$,
        '>': _num_more$$,
        '>=': _num_more_eq$$,
        'abs': _num_abs$,
        'round': _num_round$,
        'floor': _num_floor$,
        'ceil': _num_ceil$,
        'truncate': _num_truncate$,
        'roundToDouble': _num_roundToDouble$,
        'floorToDouble': _num_floorToDouble$,
        'ceilToDouble': _num_ceilToDouble$,
        'truncateToDouble': _num_truncateToDouble$,
        'clamp': _num_clamp$,
        'toInt': _num_toInt$,
        'toDouble': _num_toDouble$,
        'toStringAsFixed': _num_toStringAsFixed$,
        'toStringAsExponential': _num_toStringAsExponential$,
        'toStringAsPrecision': _num_toStringAsPrecision$,
        'toString': _num_toString$,
        'parse': _num_parse$,
      },
      {},
    ),
    'Object': m.ClassMirror(
      'Object',
      {
        '#as': Object_as$,
        '#is': Object_is$,
        'hashCode': _Object_hashCode$,
        'runtimeType': _Object_runtimeType$,
        '==': _Object_eq$$,
        'toString': _Object_toString$,
        'noSuchMethod': _Object_noSuchMethod$,
      },
      {},
    ),
    'Pattern': m.ClassMirror(
      'Pattern',
      {
        '#as': Pattern_as$,
        '#is': Pattern_is$,
        'allMatches': _Pattern_allMatches$,
        'matchAsPrefix': _Pattern_matchAsPrefix$,
      },
      {},
    ),
    'Match': m.ClassMirror(
      'Match',
      {
        '#as': Match_as$,
        '#is': Match_is$,
        'start': _Match_start$,
        'end': _Match_end$,
        'groupCount': _Match_groupCount$,
        'input': _Match_input$,
        'pattern': _Match_pattern$,
        'group': _Match_group$,
        '[]': _Match_$index$$,
        'groups': _Match_groups$,
      },
      {},
    ),
    'RegExp': m.ClassMirror(
      'RegExp',
      {
        '#as': RegExp_as$,
        '#is': RegExp_is$,
        'pattern': _RegExp_pattern$,
        'isMultiLine': _RegExp_isMultiLine$,
        'isCaseSensitive': _RegExp_isCaseSensitive$,
        'isUnicode': _RegExp_isUnicode$,
        'isDotAll': _RegExp_isDotAll$,
        'firstMatch': _RegExp_firstMatch$,
        'allMatches': _RegExp_allMatches$,
        'hasMatch': _RegExp_hasMatch$,
        'stringMatch': _RegExp_stringMatch$,
      },
      {},
    ),
    'RegExpMatch': m.ClassMirror(
      'RegExpMatch',
      {
        '#as': RegExpMatch_as$,
        '#is': RegExpMatch_is$,
        'groupNames': _RegExpMatch_groupNames$,
        'pattern': _RegExpMatch_pattern$,
        'namedGroup': _RegExpMatch_namedGroup$,
      },
      {},
    ),
    'Set': m.ClassMirror(
      'Set',
      {
        '#as': Set_as$,
        '#is': Set_is$,
        'iterator': _Set_iterator$,
        'castFrom': _Set_castFrom$,
        'cast': _Set_cast$,
        'contains': _Set_contains$,
        'add': _Set_add$,
        'addAll': _Set_addAll$,
        'remove': _Set_remove$,
        'lookup': _Set_lookup$,
        'removeAll': _Set_removeAll$,
        'retainAll': _Set_retainAll$,
        'removeWhere': _Set_removeWhere$,
        'retainWhere': _Set_retainWhere$,
        'containsAll': _Set_containsAll$,
        'intersection': _Set_intersection$,
        'union': _Set_union$,
        'difference': _Set_difference$,
        'clear': _Set_clear$,
        'toSet': _Set_toSet$,
      },
      {},
    ),
    'Sink': m.ClassMirror(
      'Sink',
      {
        '#as': Sink_as$,
        '#is': Sink_is$,
        'add': _Sink_add$,
        'close': _Sink_close$,
      },
      {},
    ),
    'StackTrace': m.ClassMirror(
      'StackTrace',
      {
        '#as': StackTrace_as$,
        '#is': StackTrace_is$,
        'toString': _StackTrace_toString$,
      },
      {},
    ),
    'Stopwatch': m.ClassMirror(
      'Stopwatch',
      {
        '#as': Stopwatch_as$,
        '#is': Stopwatch_is$,
        'frequency': _Stopwatch_frequency$,
        'elapsedTicks': _Stopwatch_elapsedTicks$,
        'elapsed': _Stopwatch_elapsed$,
        'elapsedMicroseconds': _Stopwatch_elapsedMicroseconds$,
        'elapsedMilliseconds': _Stopwatch_elapsedMilliseconds$,
        'isRunning': _Stopwatch_isRunning$,
        'start': _Stopwatch_start$,
        'stop': _Stopwatch_stop$,
        'reset': _Stopwatch_reset$,
      },
      {},
    ),
    'String': m.ClassMirror(
      'String',
      {
        '#as': String_as$,
        '#is': String_is$,
        'length': _String_length$,
        'hashCode': _String_hashCode$,
        'isEmpty': _String_isEmpty$,
        'isNotEmpty': _String_isNotEmpty$,
        'codeUnits': _String_codeUnits$,
        'runes': _String_runes$,
        '[]': _String_$index$$,
        'codeUnitAt': _String_codeUnitAt$,
        '==': _String_eq$$,
        'compareTo': _String_compareTo$,
        'endsWith': _String_endsWith$,
        'startsWith': _String_startsWith$,
        'indexOf': _String_indexOf$,
        'lastIndexOf': _String_lastIndexOf$,
        '+': _String_plus$$,
        'substring': _String_substring$,
        'trim': _String_trim$,
        'trimLeft': _String_trimLeft$,
        'trimRight': _String_trimRight$,
        '*': _String_times$$,
        'padLeft': _String_padLeft$,
        'padRight': _String_padRight$,
        'contains': _String_contains$,
        'replaceFirst': _String_replaceFirst$,
        'replaceFirstMapped': _String_replaceFirstMapped$,
        'replaceAll': _String_replaceAll$,
        'replaceAllMapped': _String_replaceAllMapped$,
        'replaceRange': _String_replaceRange$,
        'split': _String_split$,
        'splitMapJoin': _String_splitMapJoin$,
        'toLowerCase': _String_toLowerCase$,
        'toUpperCase': _String_toUpperCase$,
      },
      {},
    ),
    'Runes': m.ClassMirror(
      'Runes',
      {
        '#as': Runes_as$,
        '#is': Runes_is$,
        'string': _Runes_string$,
        'iterator': _Runes_iterator$,
        'last': _Runes_last$,
      },
      {},
    ),
    'RuneIterator': m.ClassMirror(
      'RuneIterator',
      {
        '#as': RuneIterator_as$,
        '#is': RuneIterator_is$,
        'string': _RuneIterator_string$,
        'rawIndex': _RuneIterator_rawIndex$,
        'current': _RuneIterator_current$,
        'currentSize': _RuneIterator_currentSize$,
        'currentAsString': _RuneIterator_currentAsString$,
        'reset': _RuneIterator_reset$,
        'moveNext': _RuneIterator_moveNext$,
        'movePrevious': _RuneIterator_movePrevious$,
      },
      {'rawIndex': _RuneIterator_rawIndex_set$},
    ),
    'StringBuffer': m.ClassMirror(
      'StringBuffer',
      {
        '#as': StringBuffer_as$,
        '#is': StringBuffer_is$,
        'length': _StringBuffer_length$,
        'isEmpty': _StringBuffer_isEmpty$,
        'isNotEmpty': _StringBuffer_isNotEmpty$,
        'write': _StringBuffer_write$,
        'writeCharCode': _StringBuffer_writeCharCode$,
        'writeAll': _StringBuffer_writeAll$,
        'writeln': _StringBuffer_writeln$,
        'clear': _StringBuffer_clear$,
        'toString': _StringBuffer_toString$,
      },
      {},
    ),
    'StringSink': m.ClassMirror(
      'StringSink',
      {
        '#as': StringSink_as$,
        '#is': StringSink_is$,
        'write': _StringSink_write$,
        'writeAll': _StringSink_writeAll$,
        'writeln': _StringSink_writeln$,
        'writeCharCode': _StringSink_writeCharCode$,
      },
      {},
    ),
    'Symbol': m.ClassMirror(
      'Symbol',
      {
        '#as': Symbol_as$,
        '#is': Symbol_is$,
        'hashCode': _Symbol_hashCode$,
        '==': _Symbol_eq$$,
      },
      {},
    ),
    'Type': m.ClassMirror(
      'Type',
      {
        '#as': Type_as$,
        '#is': Type_is$,
        'hashCode': _Type_hashCode$,
        '==': _Type_eq$$,
        'toString': _Type_toString$,
      },
      {},
    ),
    'Uri': m.ClassMirror(
      'Uri',
      {
        '#as': Uri_as$,
        '#is': Uri_is$,
        'scheme': _Uri_scheme$,
        'authority': _Uri_authority$,
        'userInfo': _Uri_userInfo$,
        'host': _Uri_host$,
        'port': _Uri_port$,
        'path': _Uri_path$,
        'query': _Uri_query$,
        'fragment': _Uri_fragment$,
        'pathSegments': _Uri_pathSegments$,
        'queryParameters': _Uri_queryParameters$,
        'queryParametersAll': _Uri_queryParametersAll$,
        'isAbsolute': _Uri_isAbsolute$,
        'hasScheme': _Uri_hasScheme$,
        'hasAuthority': _Uri_hasAuthority$,
        'hasPort': _Uri_hasPort$,
        'hasQuery': _Uri_hasQuery$,
        'hasFragment': _Uri_hasFragment$,
        'hasEmptyPath': _Uri_hasEmptyPath$,
        'hasAbsolutePath': _Uri_hasAbsolutePath$,
        'origin': _Uri_origin$,
        'data': _Uri_data$,
        'hashCode': _Uri_hashCode$,
        'isScheme': _Uri_isScheme$,
        'toFilePath': _Uri_toFilePath$,
        '==': _Uri_eq$$,
        'toString': _Uri_toString$,
        'replace': _Uri_replace$,
        'removeFragment': _Uri_removeFragment$,
        'resolve': _Uri_resolve$,
        'resolveUri': _Uri_resolveUri$,
        'normalizePath': _Uri_normalizePath$,
      },
      {},
    ),
    'UriData': m.ClassMirror(
      'UriData',
      {
        '#as': UriData_as$,
        '#is': UriData_is$,
        'uri': _UriData_uri$,
        'mimeType': _UriData_mimeType$,
        'charset': _UriData_charset$,
        'isBase64': _UriData_isBase64$,
        'contentText': _UriData_contentText$,
        'parameters': _UriData_parameters$,
        'isMimeType': _UriData_isMimeType$,
        'isCharset': _UriData_isCharset$,
        'isEncoding': _UriData_isEncoding$,
        'contentAsBytes': _UriData_contentAsBytes$,
        'contentAsString': _UriData_contentAsString$,
        'toString': _UriData_toString$,
      },
      {},
    ),
    'Expando': m.ClassMirror(
      'Expando',
      {
        '#as': Expando_as$,
        '#is': Expando_is$,
        'name': _Expando_name$,
        'toString': _Expando_toString$,
        '[]': _Expando_$index$$,
        '[]=': _Expando_$index_set$$,
      },
      {},
    ),
    'WeakReference': m.ClassMirror(
      'WeakReference',
      {
        '#as': WeakReference_as$,
        '#is': WeakReference_is$,
        'target': _WeakReference_target$,
      },
      {},
    ),
    'Finalizer': m.ClassMirror(
      'Finalizer',
      {
        '#as': Finalizer_as$,
        '#is': Finalizer_is$,
        'attach': _Finalizer_attach$,
        'detach': _Finalizer_detach$,
      },
      {},
    ),
  },
);
Function _deprecated$(m.Scope scope$) => () => deprecated;
Function _override$(m.Scope scope$) => () => override;
Function Deprecated_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Deprecated;
Function Deprecated_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Deprecated;
Function _Deprecated_message$(
  m.Scope scope$,
  Deprecated target$,
) =>
    () {
      return target$.message;
    };
Function _Deprecated__$(m.Scope scope$) => (String message) {
      return $Deprecated(message);
    };
Function _Deprecated_toString$(
  m.Scope scope$,
  Deprecated target$,
) =>
    target$.toString;
Function pragma_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as pragma;
Function pragma_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is pragma;
Function _pragma_name$(
  m.Scope scope$,
  pragma target$,
) =>
    () {
      return target$.name;
    };
Function _pragma_options$(
  m.Scope scope$,
  pragma target$,
) =>
    () {
      return target$.options;
    };
Function _pragma__$(m.Scope scope$) => (
      String name, [
      Object? options,
    ]) {
      if (options == null) {
        return pragma(name);
      }
      return pragma(
        name,
        options!,
      );
    };
Function BigInt_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BigInt;
Function BigInt_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BigInt;
Function _BigInt_zero$(m.Scope scope$) => () => BigInt.zero;
Function _BigInt_one$(m.Scope scope$) => () => BigInt.one;
Function _BigInt_two$(m.Scope scope$) => () => BigInt.two;
Function _BigInt_bitLength$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.bitLength;
    };
Function _BigInt_sign$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.sign;
    };
Function _BigInt_isEven$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.isEven;
    };
Function _BigInt_isOdd$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.isOdd;
    };
Function _BigInt_isNegative$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.isNegative;
    };
Function _BigInt_isValidInt$(
  m.Scope scope$,
  BigInt target$,
) =>
    () {
      return target$.isValidInt;
    };
Function _BigInt_from_$(m.Scope scope$) => BigInt.from;
Function _BigInt_parse$(m.Scope scope$) => BigInt.parse;
Function _BigInt_tryParse$(m.Scope scope$) => BigInt.tryParse;
Function _BigInt_abs$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.abs;
Function _BigInt_unary_minus$$(
  m.Scope scope$,
  BigInt target$,
) =>
    () => -target$;
Function _BigInt_plus$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ + other$;
Function _BigInt_minus$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ - other$;
Function _BigInt_times$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ * other$;
Function _BigInt_over$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ / other$;
Function _BigInt_division$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ ~/ other$;
Function _BigInt_surplus$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ % other$;
Function _BigInt_remainder$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.remainder;
Function _BigInt_left_move$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (int other$) => target$ << other$;
Function _BigInt_right_move$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (int other$) => target$ >> other$;
Function _BigInt_bit_and$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ & other$;
Function _BigInt_bit_or$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ | other$;
Function _BigInt_bit_xor$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ ^ other$;
Function _BigInt_bit_non$$(
  m.Scope scope$,
  BigInt target$,
) =>
    () => ~target$;
Function _BigInt_low$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ < other$;
Function _BigInt_low_eq$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ <= other$;
Function _BigInt_more$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ > other$;
Function _BigInt_more_eq$$(
  m.Scope scope$,
  BigInt target$,
) =>
    (BigInt other$) => target$ >= other$;
Function _BigInt_compareTo$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.compareTo;
Function _BigInt_pow$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.pow;
Function _BigInt_modPow$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.modPow;
Function _BigInt_modInverse$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.modInverse;
Function _BigInt_gcd$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.gcd;
Function _BigInt_toUnsigned$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toUnsigned;
Function _BigInt_toSigned$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toSigned;
Function _BigInt_toInt$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toInt;
Function _BigInt_toDouble$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toDouble;
Function _BigInt_toString$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toString;
Function _BigInt_toRadixString$(
  m.Scope scope$,
  BigInt target$,
) =>
    target$.toRadixString;
Function bool_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as bool;
Function bool_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is bool;
Function _bool_hashCode$(
  m.Scope scope$,
  bool target$,
) =>
    () {
      return target$.hashCode;
    };
Function _bool_fromEnvironment_$(m.Scope scope$) => bool.fromEnvironment;
Function _bool_hasEnvironment_$(m.Scope scope$) => bool.hasEnvironment;
Function _bool_parse$(m.Scope scope$) => bool.parse;
Function _bool_tryParse$(m.Scope scope$) => bool.tryParse;
Function _bool_bit_and$$(
  m.Scope scope$,
  bool target$,
) =>
    (bool other$) => target$ & other$;
Function _bool_bit_or$$(
  m.Scope scope$,
  bool target$,
) =>
    (bool other$) => target$ | other$;
Function _bool_bit_xor$$(
  m.Scope scope$,
  bool target$,
) =>
    (bool other$) => target$ ^ other$;
Function _bool_toString$(
  m.Scope scope$,
  bool target$,
) =>
    target$.toString;
Function Comparable_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Comparable<T>;
Function Comparable_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Comparable<T>;
Function _Comparable_compareTo$<T>(
  m.Scope scope$,
  Comparable<T> target$,
) =>
    target$.compareTo;
Function _Comparable_compare$(m.Scope scope$) => Comparable.compare;
Function DateTime_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DateTime;
Function DateTime_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DateTime;
Function _DateTime_monday$(m.Scope scope$) => () => DateTime.monday;
Function _DateTime_tuesday$(m.Scope scope$) => () => DateTime.tuesday;
Function _DateTime_wednesday$(m.Scope scope$) => () => DateTime.wednesday;
Function _DateTime_thursday$(m.Scope scope$) => () => DateTime.thursday;
Function _DateTime_friday$(m.Scope scope$) => () => DateTime.friday;
Function _DateTime_saturday$(m.Scope scope$) => () => DateTime.saturday;
Function _DateTime_sunday$(m.Scope scope$) => () => DateTime.sunday;
Function _DateTime_daysPerWeek$(m.Scope scope$) => () => DateTime.daysPerWeek;
Function _DateTime_january$(m.Scope scope$) => () => DateTime.january;
Function _DateTime_february$(m.Scope scope$) => () => DateTime.february;
Function _DateTime_march$(m.Scope scope$) => () => DateTime.march;
Function _DateTime_april$(m.Scope scope$) => () => DateTime.april;
Function _DateTime_may$(m.Scope scope$) => () => DateTime.may;
Function _DateTime_june$(m.Scope scope$) => () => DateTime.june;
Function _DateTime_july$(m.Scope scope$) => () => DateTime.july;
Function _DateTime_august$(m.Scope scope$) => () => DateTime.august;
Function _DateTime_september$(m.Scope scope$) => () => DateTime.september;
Function _DateTime_october$(m.Scope scope$) => () => DateTime.october;
Function _DateTime_november$(m.Scope scope$) => () => DateTime.november;
Function _DateTime_december$(m.Scope scope$) => () => DateTime.december;
Function _DateTime_monthsPerYear$(m.Scope scope$) =>
    () => DateTime.monthsPerYear;
Function _DateTime_isUtc$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.isUtc;
    };
Function _DateTime_hashCode$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.hashCode;
    };
Function _DateTime_millisecondsSinceEpoch$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.millisecondsSinceEpoch;
    };
Function _DateTime_microsecondsSinceEpoch$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.microsecondsSinceEpoch;
    };
Function _DateTime_timeZoneName$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.timeZoneName;
    };
Function _DateTime_timeZoneOffset$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.timeZoneOffset;
    };
Function _DateTime_year$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.year;
    };
Function _DateTime_month$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.month;
    };
Function _DateTime_day$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.day;
    };
Function _DateTime_hour$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.hour;
    };
Function _DateTime_minute$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.minute;
    };
Function _DateTime_second$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.second;
    };
Function _DateTime_millisecond$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.millisecond;
    };
Function _DateTime_microsecond$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.microsecond;
    };
Function _DateTime_weekday$(
  m.Scope scope$,
  DateTime target$,
) =>
    () {
      return target$.weekday;
    };
Function _DateTime__$(m.Scope scope$) => (
      int year, [
      int? month,
      int? day,
      int? hour,
      int? minute,
      int? second,
      int? millisecond,
      int? microsecond,
    ]) {
      if (month == null &&
          day == null &&
          hour == null &&
          minute == null &&
          second == null &&
          millisecond == null &&
          microsecond == null) {
        return DateTime(year);
      }
      if (day == null &&
          hour == null &&
          minute == null &&
          second == null &&
          millisecond == null &&
          microsecond == null) {
        return DateTime(
          year,
          month!,
        );
      }
      if (hour == null &&
          minute == null &&
          second == null &&
          millisecond == null &&
          microsecond == null) {
        return DateTime(
          year,
          month!,
          day!,
        );
      }
      if (minute == null &&
          second == null &&
          millisecond == null &&
          microsecond == null) {
        return DateTime(
          year,
          month!,
          day!,
          hour!,
        );
      }
      if (second == null && millisecond == null && microsecond == null) {
        return DateTime(
          year,
          month!,
          day!,
          hour!,
          minute!,
        );
      }
      if (millisecond == null && microsecond == null) {
        return DateTime(
          year,
          month!,
          day!,
          hour!,
          minute!,
          second!,
        );
      }
      if (microsecond == null) {
        return DateTime(
          year,
          month!,
          day!,
          hour!,
          minute!,
          second!,
          millisecond!,
        );
      }
      return DateTime(
        year,
        month!,
        day!,
        hour!,
        minute!,
        second!,
        millisecond!,
        microsecond!,
      );
    };
Function _DateTime_utc_$(m.Scope scope$) => DateTime.utc;
Function _DateTime_now_$(m.Scope scope$) => DateTime.now;
Function _DateTime_timestamp_$(m.Scope scope$) => DateTime.timestamp;
Function _DateTime_fromMillisecondsSinceEpoch_$(m.Scope scope$) =>
    DateTime.fromMillisecondsSinceEpoch;
Function _DateTime_fromMicrosecondsSinceEpoch_$(m.Scope scope$) =>
    DateTime.fromMicrosecondsSinceEpoch;
Function _DateTime_parse$(m.Scope scope$) => DateTime.parse;
Function _DateTime_tryParse$(m.Scope scope$) => DateTime.tryParse;
Function _DateTime_eq$$(
  m.Scope scope$,
  DateTime target$,
) =>
    (Object other$) => target$ == other$;
Function _DateTime_isBefore$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.isBefore;
Function _DateTime_isAfter$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.isAfter;
Function _DateTime_isAtSameMomentAs$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.isAtSameMomentAs;
Function _DateTime_compareTo$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.compareTo;
Function _DateTime_toLocal$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.toLocal;
Function _DateTime_toUtc$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.toUtc;
Function _DateTime_toString$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.toString;
Function _DateTime_toIso8601String$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.toIso8601String;
Function _DateTime_add$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.add;
Function _DateTime_subtract$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.subtract;
Function _DateTime_difference$(
  m.Scope scope$,
  DateTime target$,
) =>
    target$.difference;
Function double_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as double;
Function double_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is double;
Function _double_nan$(m.Scope scope$) => () => double.nan;
Function _double_infinity$(m.Scope scope$) => () => double.infinity;
Function _double_negativeInfinity$(m.Scope scope$) =>
    () => double.negativeInfinity;
Function _double_minPositive$(m.Scope scope$) => () => double.minPositive;
Function _double_maxFinite$(m.Scope scope$) => () => double.maxFinite;
Function _double_sign$(
  m.Scope scope$,
  double target$,
) =>
    () {
      return target$.sign;
    };
Function _double_remainder$(
  m.Scope scope$,
  double target$,
) =>
    target$.remainder;
Function _double_plus$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ + other$;
Function _double_minus$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ - other$;
Function _double_times$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ * other$;
Function _double_surplus$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ % other$;
Function _double_over$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ / other$;
Function _double_division$$(
  m.Scope scope$,
  double target$,
) =>
    (num other$) => target$ ~/ other$;
Function _double_unary_minus$$(
  m.Scope scope$,
  double target$,
) =>
    () => -target$;
Function _double_abs$(
  m.Scope scope$,
  double target$,
) =>
    target$.abs;
Function _double_round$(
  m.Scope scope$,
  double target$,
) =>
    target$.round;
Function _double_floor$(
  m.Scope scope$,
  double target$,
) =>
    target$.floor;
Function _double_ceil$(
  m.Scope scope$,
  double target$,
) =>
    target$.ceil;
Function _double_truncate$(
  m.Scope scope$,
  double target$,
) =>
    target$.truncate;
Function _double_roundToDouble$(
  m.Scope scope$,
  double target$,
) =>
    target$.roundToDouble;
Function _double_floorToDouble$(
  m.Scope scope$,
  double target$,
) =>
    target$.floorToDouble;
Function _double_ceilToDouble$(
  m.Scope scope$,
  double target$,
) =>
    target$.ceilToDouble;
Function _double_truncateToDouble$(
  m.Scope scope$,
  double target$,
) =>
    target$.truncateToDouble;
Function _double_toString$(
  m.Scope scope$,
  double target$,
) =>
    target$.toString;
Function _double_parse$(m.Scope scope$) => double.parse;
Function _double_tryParse$(m.Scope scope$) => double.tryParse;
Function Duration_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Duration;
Function Duration_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Duration;
Function _Duration_microsecondsPerMillisecond$(m.Scope scope$) =>
    () => Duration.microsecondsPerMillisecond;
Function _Duration_millisecondsPerSecond$(m.Scope scope$) =>
    () => Duration.millisecondsPerSecond;
Function _Duration_secondsPerMinute$(m.Scope scope$) =>
    () => Duration.secondsPerMinute;
Function _Duration_minutesPerHour$(m.Scope scope$) =>
    () => Duration.minutesPerHour;
Function _Duration_hoursPerDay$(m.Scope scope$) => () => Duration.hoursPerDay;
Function _Duration_microsecondsPerSecond$(m.Scope scope$) =>
    () => Duration.microsecondsPerSecond;
Function _Duration_microsecondsPerMinute$(m.Scope scope$) =>
    () => Duration.microsecondsPerMinute;
Function _Duration_microsecondsPerHour$(m.Scope scope$) =>
    () => Duration.microsecondsPerHour;
Function _Duration_microsecondsPerDay$(m.Scope scope$) =>
    () => Duration.microsecondsPerDay;
Function _Duration_millisecondsPerMinute$(m.Scope scope$) =>
    () => Duration.millisecondsPerMinute;
Function _Duration_millisecondsPerHour$(m.Scope scope$) =>
    () => Duration.millisecondsPerHour;
Function _Duration_millisecondsPerDay$(m.Scope scope$) =>
    () => Duration.millisecondsPerDay;
Function _Duration_secondsPerHour$(m.Scope scope$) =>
    () => Duration.secondsPerHour;
Function _Duration_secondsPerDay$(m.Scope scope$) =>
    () => Duration.secondsPerDay;
Function _Duration_minutesPerDay$(m.Scope scope$) =>
    () => Duration.minutesPerDay;
Function _Duration_zero$(m.Scope scope$) => () => Duration.zero;
Function _Duration_inDays$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inDays;
    };
Function _Duration_inHours$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inHours;
    };
Function _Duration_inMinutes$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inMinutes;
    };
Function _Duration_inSeconds$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inSeconds;
    };
Function _Duration_inMilliseconds$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inMilliseconds;
    };
Function _Duration_inMicroseconds$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.inMicroseconds;
    };
Function _Duration_hashCode$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Duration_isNegative$(
  m.Scope scope$,
  Duration target$,
) =>
    () {
      return target$.isNegative;
    };
Function _Duration__$(m.Scope scope$) => ({
      int? days,
      int? hours,
      int? minutes,
      int? seconds,
      int? milliseconds,
      int? microseconds,
    }) {
      return Duration(
        days: days ?? 0,
        hours: hours ?? 0,
        microseconds: microseconds ?? 0,
        milliseconds: milliseconds ?? 0,
        minutes: minutes ?? 0,
        seconds: seconds ?? 0,
      );
    };
Function _Duration_plus$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ + other$;
Function _Duration_minus$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ - other$;
Function _Duration_times$$(
  m.Scope scope$,
  Duration target$,
) =>
    (num other$) => target$ * other$;
Function _Duration_division$$(
  m.Scope scope$,
  Duration target$,
) =>
    (int other$) => target$ ~/ other$;
Function _Duration_low$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ < other$;
Function _Duration_more$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ > other$;
Function _Duration_low_eq$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ <= other$;
Function _Duration_more_eq$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Duration other$) => target$ >= other$;
Function _Duration_eq$$(
  m.Scope scope$,
  Duration target$,
) =>
    (Object other$) => target$ == other$;
Function _Duration_compareTo$(
  m.Scope scope$,
  Duration target$,
) =>
    target$.compareTo;
Function _Duration_toString$(
  m.Scope scope$,
  Duration target$,
) =>
    target$.toString;
Function _Duration_abs$(
  m.Scope scope$,
  Duration target$,
) =>
    target$.abs;
Function _Duration_unary_minus$$(
  m.Scope scope$,
  Duration target$,
) =>
    () => -target$;
Function Enum_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Enum;
Function Enum_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Enum;
Function _Enum_index$(
  m.Scope scope$,
  Enum target$,
) =>
    () {
      return target$.index;
    };
Function _Enum_compareByIndex$<T extends Enum>(m.Scope scope$) =>
    Enum.compareByIndex<T>;
Function _Enum_compareByName$<T extends Enum>(m.Scope scope$) =>
    Enum.compareByName<T>;
Function Error_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Error;
Function Error_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Error;
Function _Error_stackTrace$(
  m.Scope scope$,
  Error target$,
) =>
    () {
      return target$.stackTrace;
    };
Function _Error__$(m.Scope scope$) => () {
      return Error();
    };
Function _Error_safeToString$(m.Scope scope$) => Error.safeToString;
Function _Error_throwWithStackTrace$(m.Scope scope$) =>
    Error.throwWithStackTrace;
Function AssertionError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AssertionError;
Function AssertionError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AssertionError;
Function _AssertionError_message$(
  m.Scope scope$,
  AssertionError target$,
) =>
    () {
      return target$.message;
    };
Function _AssertionError__$(m.Scope scope$) => ([Object? message]) {
      if (message == null) {
        return AssertionError();
      }
      return AssertionError(message!);
    };
Function _AssertionError_toString$(
  m.Scope scope$,
  AssertionError target$,
) =>
    target$.toString;
Function TypeError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TypeError;
Function TypeError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TypeError;
Function _TypeError__$(m.Scope scope$) => () {
      return TypeError();
    };
Function ArgumentError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ArgumentError;
Function ArgumentError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ArgumentError;
Function _ArgumentError_invalidValue$(
  m.Scope scope$,
  ArgumentError target$,
) =>
    () {
      return target$.invalidValue;
    };
Function _ArgumentError_name$(
  m.Scope scope$,
  ArgumentError target$,
) =>
    () {
      return target$.name;
    };
Function _ArgumentError_message$(
  m.Scope scope$,
  ArgumentError target$,
) =>
    () {
      return target$.message;
    };
Function _ArgumentError__$(m.Scope scope$) => ([
      dynamic? message,
      String? name,
    ]) {
      if (message == null && name == null) {
        return ArgumentError();
      }
      if (name == null) {
        return ArgumentError(message!);
      }
      return ArgumentError(
        message!,
        name!,
      );
    };
Function _ArgumentError_value_$(m.Scope scope$) => ArgumentError.value;
Function _ArgumentError_notNull_$(m.Scope scope$) => ArgumentError.notNull;
Function _ArgumentError_checkNotNull$<T>(m.Scope scope$) =>
    ArgumentError.checkNotNull<T>;
Function _ArgumentError_toString$(
  m.Scope scope$,
  ArgumentError target$,
) =>
    target$.toString;
Function RangeError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RangeError;
Function RangeError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RangeError;
Function _RangeError_start$(
  m.Scope scope$,
  RangeError target$,
) =>
    () {
      return target$.start;
    };
Function _RangeError_end$(
  m.Scope scope$,
  RangeError target$,
) =>
    () {
      return target$.end;
    };
Function _RangeError_invalidValue$(
  m.Scope scope$,
  RangeError target$,
) =>
    () {
      return target$.invalidValue;
    };
Function _RangeError__$(m.Scope scope$) => (dynamic message) {
      return RangeError(message);
    };
Function _RangeError_value_$(m.Scope scope$) => RangeError.value;
Function _RangeError_range_$(m.Scope scope$) => RangeError.range;
Function _RangeError_index_$(m.Scope scope$) => RangeError.index;
Function _RangeError_checkValueInInterval$(m.Scope scope$) =>
    RangeError.checkValueInInterval;
Function _RangeError_checkValidIndex$(m.Scope scope$) =>
    RangeError.checkValidIndex;
Function _RangeError_checkValidRange$(m.Scope scope$) =>
    RangeError.checkValidRange;
Function _RangeError_checkNotNegative$(m.Scope scope$) =>
    RangeError.checkNotNegative;
Function IndexError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IndexError;
Function IndexError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IndexError;
Function _IndexError_indexable$(
  m.Scope scope$,
  IndexError target$,
) =>
    () {
      return target$.indexable;
    };
Function _IndexError_length$(
  m.Scope scope$,
  IndexError target$,
) =>
    () {
      return target$.length;
    };
Function _IndexError_invalidValue$(
  m.Scope scope$,
  IndexError target$,
) =>
    () {
      return target$.invalidValue;
    };
Function _IndexError_start$(
  m.Scope scope$,
  IndexError target$,
) =>
    () {
      return target$.start;
    };
Function _IndexError_end$(
  m.Scope scope$,
  IndexError target$,
) =>
    () {
      return target$.end;
    };
Function _IndexError_withLength_$(m.Scope scope$) => IndexError.withLength;
Function _IndexError_check$(m.Scope scope$) => IndexError.check;
Function NoSuchMethodError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as NoSuchMethodError;
Function NoSuchMethodError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is NoSuchMethodError;
Function _NoSuchMethodError_withInvocation_$(m.Scope scope$) =>
    NoSuchMethodError.withInvocation;
Function _NoSuchMethodError_toString$(
  m.Scope scope$,
  NoSuchMethodError target$,
) =>
    target$.toString;
Function UnsupportedError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnsupportedError;
Function UnsupportedError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnsupportedError;
Function _UnsupportedError_message$(
  m.Scope scope$,
  UnsupportedError target$,
) =>
    () {
      return target$.message;
    };
Function _UnsupportedError__$(m.Scope scope$) => (String message) {
      return UnsupportedError(message);
    };
Function _UnsupportedError_toString$(
  m.Scope scope$,
  UnsupportedError target$,
) =>
    target$.toString;
Function UnimplementedError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnimplementedError;
Function UnimplementedError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnimplementedError;
Function _UnimplementedError_message$(
  m.Scope scope$,
  UnimplementedError target$,
) =>
    () {
      return target$.message;
    };
Function _UnimplementedError__$(m.Scope scope$) => ([String? message]) {
      if (message == null) {
        return UnimplementedError();
      }
      return UnimplementedError(message!);
    };
Function _UnimplementedError_toString$(
  m.Scope scope$,
  UnimplementedError target$,
) =>
    target$.toString;
Function StateError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StateError;
Function StateError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StateError;
Function _StateError_message$(
  m.Scope scope$,
  StateError target$,
) =>
    () {
      return target$.message;
    };
Function _StateError__$(m.Scope scope$) => (String message) {
      return StateError(message);
    };
Function _StateError_toString$(
  m.Scope scope$,
  StateError target$,
) =>
    target$.toString;
Function ConcurrentModificationError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ConcurrentModificationError;
Function ConcurrentModificationError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ConcurrentModificationError;
Function _ConcurrentModificationError_modifiedObject$(
  m.Scope scope$,
  ConcurrentModificationError target$,
) =>
    () {
      return target$.modifiedObject;
    };
Function _ConcurrentModificationError__$(m.Scope scope$) =>
    ([Object? modifiedObject]) {
      if (modifiedObject == null) {
        return ConcurrentModificationError();
      }
      return ConcurrentModificationError(modifiedObject!);
    };
Function _ConcurrentModificationError_toString$(
  m.Scope scope$,
  ConcurrentModificationError target$,
) =>
    target$.toString;
Function OutOfMemoryError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as OutOfMemoryError;
Function OutOfMemoryError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is OutOfMemoryError;
Function _OutOfMemoryError_stackTrace$(
  m.Scope scope$,
  OutOfMemoryError target$,
) =>
    () {
      return target$.stackTrace;
    };
Function _OutOfMemoryError__$(m.Scope scope$) => () {
      return OutOfMemoryError();
    };
Function _OutOfMemoryError_toString$(
  m.Scope scope$,
  OutOfMemoryError target$,
) =>
    target$.toString;
Function StackOverflowError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StackOverflowError;
Function StackOverflowError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StackOverflowError;
Function _StackOverflowError_stackTrace$(
  m.Scope scope$,
  StackOverflowError target$,
) =>
    () {
      return target$.stackTrace;
    };
Function _StackOverflowError__$(m.Scope scope$) => () {
      return StackOverflowError();
    };
Function _StackOverflowError_toString$(
  m.Scope scope$,
  StackOverflowError target$,
) =>
    target$.toString;
Function Exception_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Exception;
Function Exception_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Exception;
Function _Exception__$(m.Scope scope$) => ([dynamic? message]) {
      if (message == null) {
        return Exception();
      }
      return Exception(message!);
    };
Function FormatException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FormatException;
Function FormatException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FormatException;
Function _FormatException_message$(
  m.Scope scope$,
  FormatException target$,
) =>
    () {
      return target$.message;
    };
Function _FormatException_source$(
  m.Scope scope$,
  FormatException target$,
) =>
    () {
      return target$.source;
    };
Function _FormatException_offset$(
  m.Scope scope$,
  FormatException target$,
) =>
    () {
      return target$.offset;
    };
Function _FormatException__$(m.Scope scope$) => ([
      String? message,
      dynamic? source,
      int? offset,
    ]) {
      if (message == null && source == null && offset == null) {
        return FormatException();
      }
      if (source == null && offset == null) {
        return FormatException(message!);
      }
      if (offset == null) {
        return FormatException(
          message!,
          source!,
        );
      }
      return FormatException(
        message!,
        source!,
        offset!,
      );
    };
Function _FormatException_toString$(
  m.Scope scope$,
  FormatException target$,
) =>
    target$.toString;
Function Function_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Function;
Function Function_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Function;
Function _Function_hashCode$(
  m.Scope scope$,
  Function target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Function_apply$(m.Scope scope$) => Function.apply;
Function _Function_eq$$(
  m.Scope scope$,
  Function target$,
) =>
    (Object other$) => target$ == other$;
Function _identical$(m.Scope scope$) => identical;
Function _identityHashCode$(m.Scope scope$) => identityHashCode;
Function int_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as int;
Function int_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is int;
Function _int_isEven$(
  m.Scope scope$,
  int target$,
) =>
    () {
      return target$.isEven;
    };
Function _int_isOdd$(
  m.Scope scope$,
  int target$,
) =>
    () {
      return target$.isOdd;
    };
Function _int_bitLength$(
  m.Scope scope$,
  int target$,
) =>
    () {
      return target$.bitLength;
    };
Function _int_sign$(
  m.Scope scope$,
  int target$,
) =>
    () {
      return target$.sign;
    };
Function _int_fromEnvironment_$(m.Scope scope$) => int.fromEnvironment;
Function _int_bit_and$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ & other$;
Function _int_bit_or$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ | other$;
Function _int_bit_xor$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ ^ other$;
Function _int_bit_non$$(
  m.Scope scope$,
  int target$,
) =>
    () => ~target$;
Function _int_left_move$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ << other$;
Function _int_right_move$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ >> other$;
Function _int_unsign_right_move$$(
  m.Scope scope$,
  int target$,
) =>
    (int other$) => target$ >>> other$;
Function _int_modPow$(
  m.Scope scope$,
  int target$,
) =>
    target$.modPow;
Function _int_modInverse$(
  m.Scope scope$,
  int target$,
) =>
    target$.modInverse;
Function _int_gcd$(
  m.Scope scope$,
  int target$,
) =>
    target$.gcd;
Function _int_toUnsigned$(
  m.Scope scope$,
  int target$,
) =>
    target$.toUnsigned;
Function _int_toSigned$(
  m.Scope scope$,
  int target$,
) =>
    target$.toSigned;
Function _int_unary_minus$$(
  m.Scope scope$,
  int target$,
) =>
    () => -target$;
Function _int_abs$(
  m.Scope scope$,
  int target$,
) =>
    target$.abs;
Function _int_round$(
  m.Scope scope$,
  int target$,
) =>
    target$.round;
Function _int_floor$(
  m.Scope scope$,
  int target$,
) =>
    target$.floor;
Function _int_ceil$(
  m.Scope scope$,
  int target$,
) =>
    target$.ceil;
Function _int_truncate$(
  m.Scope scope$,
  int target$,
) =>
    target$.truncate;
Function _int_roundToDouble$(
  m.Scope scope$,
  int target$,
) =>
    target$.roundToDouble;
Function _int_floorToDouble$(
  m.Scope scope$,
  int target$,
) =>
    target$.floorToDouble;
Function _int_ceilToDouble$(
  m.Scope scope$,
  int target$,
) =>
    target$.ceilToDouble;
Function _int_truncateToDouble$(
  m.Scope scope$,
  int target$,
) =>
    target$.truncateToDouble;
Function _int_toString$(
  m.Scope scope$,
  int target$,
) =>
    target$.toString;
Function _int_toRadixString$(
  m.Scope scope$,
  int target$,
) =>
    target$.toRadixString;
Function _int_parse$(m.Scope scope$) => int.parse;
Function _int_tryParse$(m.Scope scope$) => int.tryParse;
Function Invocation_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Invocation;
Function Invocation_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Invocation;
Function _Invocation_memberName$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.memberName;
    };
Function _Invocation_typeArguments$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.typeArguments;
    };
Function _Invocation_positionalArguments$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.positionalArguments;
    };
Function _Invocation_namedArguments$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.namedArguments;
    };
Function _Invocation_isMethod$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.isMethod;
    };
Function _Invocation_isGetter$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.isGetter;
    };
Function _Invocation_isSetter$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.isSetter;
    };
Function _Invocation_isAccessor$(
  m.Scope scope$,
  Invocation target$,
) =>
    () {
      return target$.isAccessor;
    };
Function _Invocation_method_$(m.Scope scope$) => Invocation.method;
Function _Invocation_genericMethod_$(m.Scope scope$) =>
    Invocation.genericMethod;
Function _Invocation_getter_$(m.Scope scope$) => Invocation.getter;
Function _Invocation_setter_$(m.Scope scope$) => Invocation.setter;
Function Iterable_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Iterable<E>;
Function Iterable_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Iterable<E>;
Function _Iterable_iterator$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _Iterable_length$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.length;
    };
Function _Iterable_isEmpty$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _Iterable_isNotEmpty$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _Iterable_first$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.first;
    };
Function _Iterable_last$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.last;
    };
Function _Iterable_single$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    () {
      return target$.single;
    };
Function _Iterable_generate_$(m.Scope scope$) => (
      int count, [
      m.FunctionPointer? generator,
    ]) {
      if (generator == null) {
        return Iterable.generate(count);
      }
      dynamic generatorProxy(int generator_index$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            generator!,
            [generator_index$],
            {},
          );
      return Iterable.generate(
        count,
        generator == null ? null : generatorProxy,
      );
    };
Function _Iterable_empty_$(m.Scope scope$) => Iterable.empty;
Function _Iterable_castFrom$<S, T>(m.Scope scope$) => Iterable.castFrom<S, T>;
Function _Iterable_cast$<E, R>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.cast<R>;
Function _Iterable_followedBy$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.followedBy;
Function _Iterable_map$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer toElement) {
      dynamic toElementProxy(dynamic toElement_e$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            toElement,
            [toElement_e$],
            {},
          );
      return target$.map(toElementProxy);
    };
Function _Iterable_where$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.where(testProxy);
    };
Function _Iterable_whereType$<E, T>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.whereType<T>;
Function _Iterable_expand$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer toElements) {
      Iterable toElementsProxy(dynamic toElements_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            toElements,
            [toElements_element$],
            {},
          );
      return target$.expand(toElementsProxy);
    };
Function _Iterable_contains$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.contains;
Function _Iterable_forEach$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(dynamic action_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_element$],
            {},
          );
      target$.forEach(actionProxy);
    };
Function _Iterable_reduce$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer combine) {
      dynamic combineProxy(
        dynamic combine_value$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_value$,
              combine_element$,
            ],
            {},
          );
      return target$.reduce(combineProxy);
    };
Function _Iterable_fold$(
  m.Scope scope$,
  Iterable target$,
) =>
    (
      dynamic initialValue,
      m.FunctionPointer combine,
    ) {
      dynamic combineProxy(
        dynamic combine_previousValue$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previousValue$,
              combine_element$,
            ],
            {},
          );
      return target$.fold(
        initialValue,
        combineProxy,
      );
    };
Function _Iterable_every$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.every(testProxy);
    };
Function _Iterable_join$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.join;
Function _Iterable_any$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.any(testProxy);
    };
Function _Iterable_toList$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.toList;
Function _Iterable_toSet$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.toSet;
Function _Iterable_take$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.take;
Function _Iterable_takeWhile$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      return target$.takeWhile(testProxy);
    };
Function _Iterable_skip$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.skip;
Function _Iterable_skipWhile$(
  m.Scope scope$,
  Iterable target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      return target$.skipWhile(testProxy);
    };
Function _Iterable_firstWhere$(
  m.Scope scope$,
  Iterable target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.firstWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Iterable_lastWhere$(
  m.Scope scope$,
  Iterable target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.lastWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Iterable_singleWhere$(
  m.Scope scope$,
  Iterable target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Iterable_elementAt$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.elementAt;
Function _Iterable_toString$<E>(
  m.Scope scope$,
  Iterable<E> target$,
) =>
    target$.toString;
Function _Iterable_iterableToShortString$(m.Scope scope$) =>
    Iterable.iterableToShortString;
Function _Iterable_iterableToFullString$(m.Scope scope$) =>
    Iterable.iterableToFullString;
Function Iterator_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Iterator<E>;
Function Iterator_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Iterator<E>;
Function _Iterator_current$<E>(
  m.Scope scope$,
  Iterator<E> target$,
) =>
    () {
      return target$.current;
    };
Function _Iterator_moveNext$<E>(
  m.Scope scope$,
  Iterator<E> target$,
) =>
    target$.moveNext;
Function List_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as List<E>;
Function List_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is List<E>;
void _List_first_set$<E>(
  m.Scope scope$,
  List target$,
) =>
    (dynamic other$) {
      target$.first = other$;
    };
void _List_last_set$<E>(
  m.Scope scope$,
  List target$,
) =>
    (dynamic other$) {
      target$.last = other$;
    };
Function _List_length$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    () {
      return target$.length;
    };
void _List_length_set$<E>(
  m.Scope scope$,
  List target$,
) =>
    (dynamic other$) {
      target$.length = other$;
    };
Function _List_reversed$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    () {
      return target$.reversed;
    };
Function _List_filled_$(m.Scope scope$) => List.filled;
Function _List_empty_$(m.Scope scope$) => List.empty;
Function _List_from_$(m.Scope scope$) => List.from;
Function _List_of_$(m.Scope scope$) => List.of;
Function _List_generate_$(m.Scope scope$) => (
      int length,
      m.FunctionPointer generator, {
      bool? growable,
    }) {
      dynamic generatorProxy(int generator_index$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            generator,
            [generator_index$],
            {},
          );
      return List.generate(
        length,
        generatorProxy,
        growable: growable ?? true,
      );
    };
Function _List_unmodifiable_$(m.Scope scope$) => List.unmodifiable;
Function _List_castFrom$<S, T>(m.Scope scope$) => List.castFrom<S, T>;
Function _List_copyRange$<T>(m.Scope scope$) => List.copyRange<T>;
Function _List_writeIterable$<T>(m.Scope scope$) => List.writeIterable<T>;
Function _List_cast$<E, R>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.cast<R>;
Function _List_$index$$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    (int index) => target$[index];
Function _List_$index_set$$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    (
      int index,
      E other,
    ) =>
        target$[index] = other;
Function _List_add$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.add;
Function _List_addAll$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.addAll;
Function _List_sort$(
  m.Scope scope$,
  List target$,
) =>
    ([m.FunctionPointer? compare]) {
      if (compare == null) {
        target$.sort();
      }
      int compareProxy(
        dynamic compare_a$,
        dynamic compare_b$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_a$,
              compare_b$,
            ],
            {},
          );
      target$.sort(compare == null ? null : compareProxy);
      return;
    };
Function _List_shuffle$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.shuffle;
Function _List_indexOf$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.indexOf;
Function _List_indexWhere$(
  m.Scope scope$,
  List target$,
) =>
    (
      m.FunctionPointer test, [
      int? start,
    ]) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      if (start == null) {
        return target$.indexWhere(testProxy);
      }
      return target$.indexWhere(
        testProxy,
        start!,
      );
    };
Function _List_lastIndexWhere$(
  m.Scope scope$,
  List target$,
) =>
    (
      m.FunctionPointer test, [
      int? start,
    ]) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      if (start == null) {
        return target$.lastIndexWhere(testProxy);
      }
      return target$.lastIndexWhere(
        testProxy,
        start!,
      );
    };
Function _List_lastIndexOf$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.lastIndexOf;
Function _List_clear$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.clear;
Function _List_insert$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.insert;
Function _List_insertAll$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.insertAll;
Function _List_setAll$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.setAll;
Function _List_remove$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.remove;
Function _List_removeAt$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.removeAt;
Function _List_removeLast$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.removeLast;
Function _List_removeWhere$(
  m.Scope scope$,
  List target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _List_retainWhere$(
  m.Scope scope$,
  List target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _List_plus$$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    (List<E> other$) => target$ + other$;
Function _List_sublist$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.sublist;
Function _List_getRange$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.getRange;
Function _List_setRange$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.setRange;
Function _List_removeRange$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.removeRange;
Function _List_fillRange$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.fillRange;
Function _List_replaceRange$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.replaceRange;
Function _List_asMap$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    target$.asMap;
Function _List_eq$$<E>(
  m.Scope scope$,
  List<E> target$,
) =>
    (Object other$) => target$ == other$;
Function Map_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Map<K, V>;
Function Map_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Map<K, V>;
Function _Map_entries$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.entries;
    };
Function _Map_keys$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.keys;
    };
Function _Map_values$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.values;
    };
Function _Map_length$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.length;
    };
Function _Map_isEmpty$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _Map_isNotEmpty$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _Map__$(m.Scope scope$) => () {
      return Map();
    };
Function _Map_from_$(m.Scope scope$) => Map.from;
Function _Map_of_$(m.Scope scope$) => Map.of;
Function _Map_unmodifiable_$(m.Scope scope$) => Map.unmodifiable;
Function _Map_identity_$(m.Scope scope$) => Map.identity;
Function _Map_fromIterable_$(m.Scope scope$) => (
      Iterable iterable, {
      m.FunctionPointer? key,
      m.FunctionPointer? value,
    }) {
      dynamic keyProxy(dynamic key_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            key!,
            [key_element$],
            {},
          );
      dynamic valueProxy(dynamic value_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_element$],
            {},
          );
      return Map.fromIterable(
        Iterable.castFrom(iterable),
        key: key == null ? null : keyProxy,
        value: value == null ? null : valueProxy,
      );
    };
Function _Map_fromIterables_$(m.Scope scope$) => Map.fromIterables;
Function _Map_fromEntries_$(m.Scope scope$) => Map.fromEntries;
Function _Map_castFrom$<K, V, K2, V2>(m.Scope scope$) =>
    Map.castFrom<K, V, K2, V2>;
Function _Map_cast$<K, V, RK, RV>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.cast<RK, RV>;
Function _Map_containsValue$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.containsValue;
Function _Map_containsKey$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.containsKey;
Function _Map_$index$$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    (Object? index) => target$[index];
Function _Map_$index_set$$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    (
      K index,
      V other,
    ) =>
        target$[index] = other;
Function _Map_map$(
  m.Scope scope$,
  Map target$,
) =>
    (m.FunctionPointer convert) {
      MapEntry convertProxy(
        dynamic convert_key$,
        dynamic convert_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [
              convert_key$,
              convert_value$,
            ],
            {},
          );
      return target$.map(convertProxy);
    };
Function _Map_addEntries$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.addEntries;
Function _Map_update$(
  m.Scope scope$,
  Map target$,
) =>
    (
      dynamic key,
      m.FunctionPointer update, {
      m.FunctionPointer? ifAbsent,
    }) {
      dynamic updateProxy(dynamic update_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [update_value$],
            {},
          );
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent!,
            [],
            {},
          );
      return target$.update(
        key,
        updateProxy,
        ifAbsent: ifAbsent == null ? null : ifAbsentProxy,
      );
    };
Function _Map_updateAll$(
  m.Scope scope$,
  Map target$,
) =>
    (m.FunctionPointer update) {
      dynamic updateProxy(
        dynamic update_key$,
        dynamic update_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [
              update_key$,
              update_value$,
            ],
            {},
          );
      target$.updateAll(updateProxy);
    };
Function _Map_removeWhere$(
  m.Scope scope$,
  Map target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(
        dynamic test_key$,
        dynamic test_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [
              test_key$,
              test_value$,
            ],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _Map_putIfAbsent$(
  m.Scope scope$,
  Map target$,
) =>
    (
      dynamic key,
      m.FunctionPointer ifAbsent,
    ) {
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent,
            [],
            {},
          );
      return target$.putIfAbsent(
        key,
        ifAbsentProxy,
      );
    };
Function _Map_addAll$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.addAll;
Function _Map_remove$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.remove;
Function _Map_clear$<K, V>(
  m.Scope scope$,
  Map<K, V> target$,
) =>
    target$.clear;
Function _Map_forEach$(
  m.Scope scope$,
  Map target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(
        dynamic action_key$,
        dynamic action_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              action_key$,
              action_value$,
            ],
            {},
          );
      target$.forEach(actionProxy);
    };
Function MapEntry_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MapEntry<K, V>;
Function MapEntry_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MapEntry<K, V>;
Function _MapEntry_key$<K, V>(
  m.Scope scope$,
  MapEntry<K, V> target$,
) =>
    () {
      return target$.key;
    };
Function _MapEntry_value$<K, V>(
  m.Scope scope$,
  MapEntry<K, V> target$,
) =>
    () {
      return target$.value;
    };
Function _MapEntry__$(m.Scope scope$) => (
      dynamic key,
      dynamic value,
    ) {
      return MapEntry(
        key,
        value,
      );
    };
Function _MapEntry_toString$<K, V>(
  m.Scope scope$,
  MapEntry<K, V> target$,
) =>
    target$.toString;
Function Null_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Null;
Function Null_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Null;
Function _Null_hashCode$(
  m.Scope scope$,
  Null target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Null_toString$(
  m.Scope scope$,
  Null target$,
) =>
    target$.toString;
Function num_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as num;
Function num_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is num;
Function _num_hashCode$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.hashCode;
    };
Function _num_isNaN$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.isNaN;
    };
Function _num_isNegative$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.isNegative;
    };
Function _num_isInfinite$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.isInfinite;
    };
Function _num_isFinite$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.isFinite;
    };
Function _num_sign$(
  m.Scope scope$,
  num target$,
) =>
    () {
      return target$.sign;
    };
Function _num_eq$$(
  m.Scope scope$,
  num target$,
) =>
    (Object other$) => target$ == other$;
Function _num_compareTo$(
  m.Scope scope$,
  num target$,
) =>
    target$.compareTo;
Function _num_plus$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ + other$;
Function _num_minus$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ - other$;
Function _num_times$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ * other$;
Function _num_surplus$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ % other$;
Function _num_over$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ / other$;
Function _num_division$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ ~/ other$;
Function _num_unary_minus$$(
  m.Scope scope$,
  num target$,
) =>
    () => -target$;
Function _num_remainder$(
  m.Scope scope$,
  num target$,
) =>
    target$.remainder;
Function _num_low$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ < other$;
Function _num_low_eq$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ <= other$;
Function _num_more$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ > other$;
Function _num_more_eq$$(
  m.Scope scope$,
  num target$,
) =>
    (num other$) => target$ >= other$;
Function _num_abs$(
  m.Scope scope$,
  num target$,
) =>
    target$.abs;
Function _num_round$(
  m.Scope scope$,
  num target$,
) =>
    target$.round;
Function _num_floor$(
  m.Scope scope$,
  num target$,
) =>
    target$.floor;
Function _num_ceil$(
  m.Scope scope$,
  num target$,
) =>
    target$.ceil;
Function _num_truncate$(
  m.Scope scope$,
  num target$,
) =>
    target$.truncate;
Function _num_roundToDouble$(
  m.Scope scope$,
  num target$,
) =>
    target$.roundToDouble;
Function _num_floorToDouble$(
  m.Scope scope$,
  num target$,
) =>
    target$.floorToDouble;
Function _num_ceilToDouble$(
  m.Scope scope$,
  num target$,
) =>
    target$.ceilToDouble;
Function _num_truncateToDouble$(
  m.Scope scope$,
  num target$,
) =>
    target$.truncateToDouble;
Function _num_clamp$(
  m.Scope scope$,
  num target$,
) =>
    target$.clamp;
Function _num_toInt$(
  m.Scope scope$,
  num target$,
) =>
    target$.toInt;
Function _num_toDouble$(
  m.Scope scope$,
  num target$,
) =>
    target$.toDouble;
Function _num_toStringAsFixed$(
  m.Scope scope$,
  num target$,
) =>
    target$.toStringAsFixed;
Function _num_toStringAsExponential$(
  m.Scope scope$,
  num target$,
) =>
    target$.toStringAsExponential;
Function _num_toStringAsPrecision$(
  m.Scope scope$,
  num target$,
) =>
    target$.toStringAsPrecision;
Function _num_toString$(
  m.Scope scope$,
  num target$,
) =>
    target$.toString;
Function _num_parse$(m.Scope scope$) => (
      String input, [
      m.FunctionPointer? onError,
    ]) {
      if (onError == null) {
        return num.parse(input);
      }
      num onErrorProxy(String onError_input$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onError!,
            [onError_input$],
            {},
          );
      return num.parse(
        input,
        onError == null ? null : onErrorProxy,
      );
    };
Function _num_tryParse$(m.Scope scope$) => num.tryParse;
Function Object_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Object;
Function Object_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Object;
Function _Object_hashCode$(
  m.Scope scope$,
  Object target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Object_runtimeType$(
  m.Scope scope$,
  Object target$,
) =>
    () {
      return target$.runtimeType;
    };
Function _Object__$(m.Scope scope$) => () {
      return Object();
    };
Function _Object_eq$$(
  m.Scope scope$,
  Object target$,
) =>
    (Object other$) => target$ == other$;
Function _Object_toString$(
  m.Scope scope$,
  Object target$,
) =>
    target$.toString;
Function _Object_noSuchMethod$(
  m.Scope scope$,
  Object target$,
) =>
    target$.noSuchMethod;
Function _Object_hash$(m.Scope scope$) => Object.hash;
Function _Object_hashAll$(m.Scope scope$) => Object.hashAll;
Function _Object_hashAllUnordered$(m.Scope scope$) => Object.hashAllUnordered;
Function Pattern_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Pattern;
Function Pattern_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Pattern;
Function _Pattern_allMatches$(
  m.Scope scope$,
  Pattern target$,
) =>
    target$.allMatches;
Function _Pattern_matchAsPrefix$(
  m.Scope scope$,
  Pattern target$,
) =>
    target$.matchAsPrefix;
Function Match_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Match;
Function Match_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Match;
Function _Match_start$(
  m.Scope scope$,
  Match target$,
) =>
    () {
      return target$.start;
    };
Function _Match_end$(
  m.Scope scope$,
  Match target$,
) =>
    () {
      return target$.end;
    };
Function _Match_groupCount$(
  m.Scope scope$,
  Match target$,
) =>
    () {
      return target$.groupCount;
    };
Function _Match_input$(
  m.Scope scope$,
  Match target$,
) =>
    () {
      return target$.input;
    };
Function _Match_pattern$(
  m.Scope scope$,
  Match target$,
) =>
    () {
      return target$.pattern;
    };
Function _Match_group$(
  m.Scope scope$,
  Match target$,
) =>
    target$.group;
Function _Match_$index$$(
  m.Scope scope$,
  Match target$,
) =>
    (int index) => target$[index];
Function _Match_groups$(
  m.Scope scope$,
  Match target$,
) =>
    target$.groups;
Function _print$(m.Scope scope$) => print;
Function RegExp_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RegExp;
Function RegExp_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RegExp;
Function _RegExp_pattern$(
  m.Scope scope$,
  RegExp target$,
) =>
    () {
      return target$.pattern;
    };
Function _RegExp_isMultiLine$(
  m.Scope scope$,
  RegExp target$,
) =>
    () {
      return target$.isMultiLine;
    };
Function _RegExp_isCaseSensitive$(
  m.Scope scope$,
  RegExp target$,
) =>
    () {
      return target$.isCaseSensitive;
    };
Function _RegExp_isUnicode$(
  m.Scope scope$,
  RegExp target$,
) =>
    () {
      return target$.isUnicode;
    };
Function _RegExp_isDotAll$(
  m.Scope scope$,
  RegExp target$,
) =>
    () {
      return target$.isDotAll;
    };
Function _RegExp__$(m.Scope scope$) => (
      String source, {
      bool? multiLine,
      bool? caseSensitive,
      bool? unicode,
      bool? dotAll,
    }) {
      return RegExp(
        source,
        caseSensitive: caseSensitive ?? true,
        dotAll: dotAll ?? false,
        multiLine: multiLine ?? false,
        unicode: unicode ?? false,
      );
    };
Function _RegExp_escape$(m.Scope scope$) => RegExp.escape;
Function _RegExp_firstMatch$(
  m.Scope scope$,
  RegExp target$,
) =>
    target$.firstMatch;
Function _RegExp_allMatches$(
  m.Scope scope$,
  RegExp target$,
) =>
    target$.allMatches;
Function _RegExp_hasMatch$(
  m.Scope scope$,
  RegExp target$,
) =>
    target$.hasMatch;
Function _RegExp_stringMatch$(
  m.Scope scope$,
  RegExp target$,
) =>
    target$.stringMatch;
Function RegExpMatch_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RegExpMatch;
Function RegExpMatch_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RegExpMatch;
Function _RegExpMatch_groupNames$(
  m.Scope scope$,
  RegExpMatch target$,
) =>
    () {
      return target$.groupNames;
    };
Function _RegExpMatch_pattern$(
  m.Scope scope$,
  RegExpMatch target$,
) =>
    () {
      return target$.pattern;
    };
Function _RegExpMatch_namedGroup$(
  m.Scope scope$,
  RegExpMatch target$,
) =>
    target$.namedGroup;
Function Set_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Set<E>;
Function Set_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Set<E>;
Function _Set_iterator$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _Set__$(m.Scope scope$) => () {
      return Set();
    };
Function _Set_identity_$(m.Scope scope$) => Set.identity;
Function _Set_from_$(m.Scope scope$) => Set.from;
Function _Set_of_$(m.Scope scope$) => Set.of;
Function _Set_unmodifiable_$(m.Scope scope$) => Set.unmodifiable;
Function _Set_castFrom$(m.Scope scope$) => (
      Set source, {
      m.FunctionPointer? newSet,
    }) {
      Set<R> newSetProxy<R>() => scope$.engine.callFunctionPointer(
            scope$,
            newSet!,
            [],
            {},
          );
      return Set.castFrom(
        Set.from(source),
        newSet: newSet == null ? null : newSetProxy,
      );
    };
Function _Set_cast$<E, R>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.cast<R>;
Function _Set_contains$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.contains;
Function _Set_add$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.add;
Function _Set_addAll$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.addAll;
Function _Set_remove$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.remove;
Function _Set_lookup$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.lookup;
Function _Set_removeAll$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.removeAll;
Function _Set_retainAll$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.retainAll;
Function _Set_removeWhere$(
  m.Scope scope$,
  Set target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _Set_retainWhere$(
  m.Scope scope$,
  Set target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _Set_containsAll$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.containsAll;
Function _Set_intersection$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.intersection;
Function _Set_union$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.union;
Function _Set_difference$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.difference;
Function _Set_clear$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.clear;
Function _Set_toSet$<E>(
  m.Scope scope$,
  Set<E> target$,
) =>
    target$.toSet;
Function Sink_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Sink<T>;
Function Sink_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Sink<T>;
Function _Sink_add$<T>(
  m.Scope scope$,
  Sink<T> target$,
) =>
    target$.add;
Function _Sink_close$<T>(
  m.Scope scope$,
  Sink<T> target$,
) =>
    target$.close;
Function StackTrace_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StackTrace;
Function StackTrace_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StackTrace;
Function _StackTrace_empty$(m.Scope scope$) => () => StackTrace.empty;
Function _StackTrace_current$(m.Scope scope$) => () => StackTrace.current;
Function _StackTrace_fromString_$(m.Scope scope$) => StackTrace.fromString;
Function _StackTrace_toString$(
  m.Scope scope$,
  StackTrace target$,
) =>
    target$.toString;
Function Stopwatch_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Stopwatch;
Function Stopwatch_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Stopwatch;
Function _Stopwatch_frequency$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.frequency;
    };
Function _Stopwatch_elapsedTicks$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.elapsedTicks;
    };
Function _Stopwatch_elapsed$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.elapsed;
    };
Function _Stopwatch_elapsedMicroseconds$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.elapsedMicroseconds;
    };
Function _Stopwatch_elapsedMilliseconds$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.elapsedMilliseconds;
    };
Function _Stopwatch_isRunning$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    () {
      return target$.isRunning;
    };
Function _Stopwatch__$(m.Scope scope$) => () {
      return Stopwatch();
    };
Function _Stopwatch_start$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    target$.start;
Function _Stopwatch_stop$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    target$.stop;
Function _Stopwatch_reset$(
  m.Scope scope$,
  Stopwatch target$,
) =>
    target$.reset;
Function String_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as String;
Function String_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is String;
Function _String_length$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.length;
    };
Function _String_hashCode$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.hashCode;
    };
Function _String_isEmpty$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _String_isNotEmpty$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _String_codeUnits$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.codeUnits;
    };
Function _String_runes$(
  m.Scope scope$,
  String target$,
) =>
    () {
      return target$.runes;
    };
Function _String_fromCharCodes_$(m.Scope scope$) => String.fromCharCodes;
Function _String_fromCharCode_$(m.Scope scope$) => String.fromCharCode;
Function _String_fromEnvironment_$(m.Scope scope$) => String.fromEnvironment;
Function _String_$index$$(
  m.Scope scope$,
  String target$,
) =>
    (int index) => target$[index];
Function _String_codeUnitAt$(
  m.Scope scope$,
  String target$,
) =>
    target$.codeUnitAt;
Function _String_eq$$(
  m.Scope scope$,
  String target$,
) =>
    (Object other$) => target$ == other$;
Function _String_compareTo$(
  m.Scope scope$,
  String target$,
) =>
    target$.compareTo;
Function _String_endsWith$(
  m.Scope scope$,
  String target$,
) =>
    target$.endsWith;
Function _String_startsWith$(
  m.Scope scope$,
  String target$,
) =>
    target$.startsWith;
Function _String_indexOf$(
  m.Scope scope$,
  String target$,
) =>
    target$.indexOf;
Function _String_lastIndexOf$(
  m.Scope scope$,
  String target$,
) =>
    target$.lastIndexOf;
Function _String_plus$$(
  m.Scope scope$,
  String target$,
) =>
    (String other$) => target$ + other$;
Function _String_substring$(
  m.Scope scope$,
  String target$,
) =>
    target$.substring;
Function _String_trim$(
  m.Scope scope$,
  String target$,
) =>
    target$.trim;
Function _String_trimLeft$(
  m.Scope scope$,
  String target$,
) =>
    target$.trimLeft;
Function _String_trimRight$(
  m.Scope scope$,
  String target$,
) =>
    target$.trimRight;
Function _String_times$$(
  m.Scope scope$,
  String target$,
) =>
    (int other$) => target$ * other$;
Function _String_padLeft$(
  m.Scope scope$,
  String target$,
) =>
    target$.padLeft;
Function _String_padRight$(
  m.Scope scope$,
  String target$,
) =>
    target$.padRight;
Function _String_contains$(
  m.Scope scope$,
  String target$,
) =>
    target$.contains;
Function _String_replaceFirst$(
  m.Scope scope$,
  String target$,
) =>
    target$.replaceFirst;
Function _String_replaceFirstMapped$(
  m.Scope scope$,
  String target$,
) =>
    (
      Pattern from,
      m.FunctionPointer replace, [
      int? startIndex,
    ]) {
      String replaceProxy(Match replace_match$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            replace,
            [replace_match$],
            {},
          );
      if (startIndex == null) {
        return target$.replaceFirstMapped(
          from,
          replaceProxy,
        );
      }
      return target$.replaceFirstMapped(
        from,
        replaceProxy,
        startIndex!,
      );
    };
Function _String_replaceAll$(
  m.Scope scope$,
  String target$,
) =>
    target$.replaceAll;
Function _String_replaceAllMapped$(
  m.Scope scope$,
  String target$,
) =>
    (
      Pattern from,
      m.FunctionPointer replace,
    ) {
      String replaceProxy(Match replace_match$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            replace,
            [replace_match$],
            {},
          );
      return target$.replaceAllMapped(
        from,
        replaceProxy,
      );
    };
Function _String_replaceRange$(
  m.Scope scope$,
  String target$,
) =>
    target$.replaceRange;
Function _String_split$(
  m.Scope scope$,
  String target$,
) =>
    target$.split;
Function _String_splitMapJoin$(
  m.Scope scope$,
  String target$,
) =>
    (
      Pattern pattern, {
      m.FunctionPointer? onMatch,
      m.FunctionPointer? onNonMatch,
    }) {
      String onMatchProxy(Match onMatch_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onMatch!,
            [onMatch_$p0$],
            {},
          );
      String onNonMatchProxy(String onNonMatch_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onNonMatch!,
            [onNonMatch_$p0$],
            {},
          );
      return target$.splitMapJoin(
        pattern,
        onMatch: onMatch == null ? null : onMatchProxy,
        onNonMatch: onNonMatch == null ? null : onNonMatchProxy,
      );
    };
Function _String_toLowerCase$(
  m.Scope scope$,
  String target$,
) =>
    target$.toLowerCase;
Function _String_toUpperCase$(
  m.Scope scope$,
  String target$,
) =>
    target$.toUpperCase;
Function Runes_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Runes;
Function Runes_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Runes;
Function _Runes_string$(
  m.Scope scope$,
  Runes target$,
) =>
    () {
      return target$.string;
    };
Function _Runes_iterator$(
  m.Scope scope$,
  Runes target$,
) =>
    () {
      return target$.iterator;
    };
Function _Runes_last$(
  m.Scope scope$,
  Runes target$,
) =>
    () {
      return target$.last;
    };
Function _Runes__$(m.Scope scope$) => (String string) {
      return Runes(string);
    };
Function RuneIterator_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RuneIterator;
Function RuneIterator_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RuneIterator;
Function _RuneIterator_string$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    () {
      return target$.string;
    };
Function _RuneIterator_rawIndex$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    () {
      return target$.rawIndex;
    };
void _RuneIterator_rawIndex_set$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    (dynamic other$) {
      target$.rawIndex = other$;
    };
Function _RuneIterator_current$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    () {
      return target$.current;
    };
Function _RuneIterator_currentSize$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    () {
      return target$.currentSize;
    };
Function _RuneIterator_currentAsString$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    () {
      return target$.currentAsString;
    };
Function _RuneIterator__$(m.Scope scope$) => (String string) {
      return RuneIterator(string);
    };
Function _RuneIterator_at_$(m.Scope scope$) => RuneIterator.at;
Function _RuneIterator_reset$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    target$.reset;
Function _RuneIterator_moveNext$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    target$.moveNext;
Function _RuneIterator_movePrevious$(
  m.Scope scope$,
  RuneIterator target$,
) =>
    target$.movePrevious;
Function StringBuffer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StringBuffer;
Function StringBuffer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StringBuffer;
Function _StringBuffer_length$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    () {
      return target$.length;
    };
Function _StringBuffer_isEmpty$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _StringBuffer_isNotEmpty$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _StringBuffer__$(m.Scope scope$) => ([Object? content]) {
      if (content == null) {
        return StringBuffer();
      }
      return StringBuffer(content!);
    };
Function _StringBuffer_write$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.write;
Function _StringBuffer_writeCharCode$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.writeCharCode;
Function _StringBuffer_writeAll$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.writeAll;
Function _StringBuffer_writeln$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.writeln;
Function _StringBuffer_clear$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.clear;
Function _StringBuffer_toString$(
  m.Scope scope$,
  StringBuffer target$,
) =>
    target$.toString;
Function StringSink_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StringSink;
Function StringSink_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StringSink;
Function _StringSink_write$(
  m.Scope scope$,
  StringSink target$,
) =>
    target$.write;
Function _StringSink_writeAll$(
  m.Scope scope$,
  StringSink target$,
) =>
    target$.writeAll;
Function _StringSink_writeln$(
  m.Scope scope$,
  StringSink target$,
) =>
    target$.writeln;
Function _StringSink_writeCharCode$(
  m.Scope scope$,
  StringSink target$,
) =>
    target$.writeCharCode;
Function Symbol_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Symbol;
Function Symbol_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Symbol;
Function _Symbol_unaryMinus$(m.Scope scope$) => () => Symbol.unaryMinus;
Function _Symbol_empty$(m.Scope scope$) => () => Symbol.empty;
Function _Symbol_hashCode$(
  m.Scope scope$,
  Symbol target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Symbol__$(m.Scope scope$) => (String name) {
      return Symbol(name);
    };
Function _Symbol_eq$$(
  m.Scope scope$,
  Symbol target$,
) =>
    (Object other$) => target$ == other$;
Function Type_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Type;
Function Type_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Type;
Function _Type_hashCode$(
  m.Scope scope$,
  Type target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Type_eq$$(
  m.Scope scope$,
  Type target$,
) =>
    (Object other$) => target$ == other$;
Function _Type_toString$(
  m.Scope scope$,
  Type target$,
) =>
    target$.toString;
Function Uri_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Uri;
Function Uri_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Uri;
Function _Uri_base$(m.Scope scope$) => () => Uri.base;
Function _Uri_scheme$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.scheme;
    };
Function _Uri_authority$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.authority;
    };
Function _Uri_userInfo$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.userInfo;
    };
Function _Uri_host$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.host;
    };
Function _Uri_port$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.port;
    };
Function _Uri_path$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.path;
    };
Function _Uri_query$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.query;
    };
Function _Uri_fragment$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.fragment;
    };
Function _Uri_pathSegments$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.pathSegments;
    };
Function _Uri_queryParameters$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.queryParameters;
    };
Function _Uri_queryParametersAll$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.queryParametersAll;
    };
Function _Uri_isAbsolute$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.isAbsolute;
    };
Function _Uri_hasScheme$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasScheme;
    };
Function _Uri_hasAuthority$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasAuthority;
    };
Function _Uri_hasPort$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasPort;
    };
Function _Uri_hasQuery$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasQuery;
    };
Function _Uri_hasFragment$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasFragment;
    };
Function _Uri_hasEmptyPath$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasEmptyPath;
    };
Function _Uri_hasAbsolutePath$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hasAbsolutePath;
    };
Function _Uri_origin$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.origin;
    };
Function _Uri_data$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.data;
    };
Function _Uri_hashCode$(
  m.Scope scope$,
  Uri target$,
) =>
    () {
      return target$.hashCode;
    };
Function _Uri__$(m.Scope scope$) => ({
      String? scheme,
      String? userInfo,
      String? host,
      int? port,
      String? path,
      Iterable? pathSegments,
      String? query,
      Map? queryParameters,
      String? fragment,
    }) {
      return Uri(
        fragment: fragment,
        host: host,
        path: path,
        pathSegments:
            pathSegments == null ? null : Iterable.castFrom(pathSegments),
        port: port,
        query: query,
        queryParameters:
            queryParameters == null ? null : Map.from(queryParameters),
        scheme: scheme,
        userInfo: userInfo,
      );
    };
Function _Uri_http_$(m.Scope scope$) => Uri.http;
Function _Uri_https_$(m.Scope scope$) => Uri.https;
Function _Uri_file_$(m.Scope scope$) => Uri.file;
Function _Uri_directory_$(m.Scope scope$) => Uri.directory;
Function _Uri_dataFromString_$(m.Scope scope$) => Uri.dataFromString;
Function _Uri_dataFromBytes_$(m.Scope scope$) => Uri.dataFromBytes;
Function _Uri_isScheme$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.isScheme;
Function _Uri_toFilePath$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.toFilePath;
Function _Uri_eq$$(
  m.Scope scope$,
  Uri target$,
) =>
    (Object other$) => target$ == other$;
Function _Uri_toString$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.toString;
Function _Uri_replace$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.replace;
Function _Uri_removeFragment$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.removeFragment;
Function _Uri_resolve$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.resolve;
Function _Uri_resolveUri$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.resolveUri;
Function _Uri_normalizePath$(
  m.Scope scope$,
  Uri target$,
) =>
    target$.normalizePath;
Function _Uri_parse$(m.Scope scope$) => Uri.parse;
Function _Uri_tryParse$(m.Scope scope$) => Uri.tryParse;
Function _Uri_encodeComponent$(m.Scope scope$) => Uri.encodeComponent;
Function _Uri_encodeQueryComponent$(m.Scope scope$) => Uri.encodeQueryComponent;
Function _Uri_decodeComponent$(m.Scope scope$) => Uri.decodeComponent;
Function _Uri_decodeQueryComponent$(m.Scope scope$) => Uri.decodeQueryComponent;
Function _Uri_encodeFull$(m.Scope scope$) => Uri.encodeFull;
Function _Uri_decodeFull$(m.Scope scope$) => Uri.decodeFull;
Function _Uri_splitQueryString$(m.Scope scope$) => Uri.splitQueryString;
Function _Uri_parseIPv4Address$(m.Scope scope$) => Uri.parseIPv4Address;
Function _Uri_parseIPv6Address$(m.Scope scope$) => Uri.parseIPv6Address;
Function UriData_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UriData;
Function UriData_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UriData;
Function _UriData_uri$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.uri;
    };
Function _UriData_mimeType$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.mimeType;
    };
Function _UriData_charset$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.charset;
    };
Function _UriData_isBase64$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.isBase64;
    };
Function _UriData_contentText$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.contentText;
    };
Function _UriData_parameters$(
  m.Scope scope$,
  UriData target$,
) =>
    () {
      return target$.parameters;
    };
Function _UriData_fromString_$(m.Scope scope$) => UriData.fromString;
Function _UriData_fromBytes_$(m.Scope scope$) => UriData.fromBytes;
Function _UriData_fromUri_$(m.Scope scope$) => UriData.fromUri;
Function _UriData_parse$(m.Scope scope$) => UriData.parse;
Function _UriData_isMimeType$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.isMimeType;
Function _UriData_isCharset$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.isCharset;
Function _UriData_isEncoding$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.isEncoding;
Function _UriData_contentAsBytes$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.contentAsBytes;
Function _UriData_contentAsString$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.contentAsString;
Function _UriData_toString$(
  m.Scope scope$,
  UriData target$,
) =>
    target$.toString;
Function Expando_as$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Expando<T>;
Function Expando_is$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Expando<T>;
Function _Expando_name$<T extends Object>(
  m.Scope scope$,
  Expando<T> target$,
) =>
    () {
      return target$.name;
    };
Function _Expando__$(m.Scope scope$) => <T extends Object>([String? name]) {
      if (name == null) {
        return Expando<T>();
      }
      return Expando<T>(name!);
    };
Function _Expando_toString$<T extends Object>(
  m.Scope scope$,
  Expando<T> target$,
) =>
    target$.toString;
Function _Expando_$index$$<T extends Object>(
  m.Scope scope$,
  Expando<T> target$,
) =>
    (Object index) => target$[index];
Function _Expando_$index_set$$<T extends Object>(
  m.Scope scope$,
  Expando<T> target$,
) =>
    (
      Object index,
      T? other,
    ) =>
        target$[index] = other;
Function WeakReference_as$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as WeakReference<T>;
Function WeakReference_is$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is WeakReference<T>;
Function _WeakReference_target$<T extends Object>(
  m.Scope scope$,
  WeakReference<T> target$,
) =>
    () {
      return target$.target;
    };
Function _WeakReference__$(m.Scope scope$) =>
    <T extends Object>(dynamic target) {
      return WeakReference<T>(target);
    };
Function Finalizer_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Finalizer<T>;
Function Finalizer_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Finalizer<T>;
Function _Finalizer__$(m.Scope scope$) => (m.FunctionPointer callback) {
      void callbackProxy(dynamic callback_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_$p0$],
            {},
          );
      return Finalizer(callbackProxy);
    };
Function _Finalizer_attach$<T>(
  m.Scope scope$,
  Finalizer<T> target$,
) =>
    target$.attach;
Function _Finalizer_detach$<T>(
  m.Scope scope$,
  Finalizer<T> target$,
) =>
    target$.detach;
