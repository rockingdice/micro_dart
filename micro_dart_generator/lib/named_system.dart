import 'package:code_builder/code_builder.dart' as cb;
import 'package:dart_style/dart_style.dart';

const Map<String, List<String>> unaryOperatorList = {
  "unary-": ["-", "unary_minus\$"],
  "unary+": ["++", "unary_plus\$"],
  "~": ["~", "bit_non\$"],
};
const Map<String, List<String>> binaryOperatorList = {
  "#as": ["as", "as\$"],
  "#is": ["is", "is\$"],
  "&": ["&", "bit_and\$"],
  "|": ["|", "bit_or\$"],
  "^": ["^", "bit_xor\$"],
  "==": ["==", "eq\$"],
  "+": ["+", "plus\$"],
  "-": ["-", "minus\$"],
  "*": ["*", "times\$"],
  "~/": ["~/", "division\$"],
  "<": ["<", "low\$"],
  ">": [">", "more\$"],
  "<=": ["<=", "low_eq\$"],
  ">=": [">=", "more_eq\$"],
  "/": ["/", "over\$"],
  "%": ["%", "surplus\$"],
  "<<": ["<<", "left_move\$"],
  ">>": [">>", "right_move\$"],
  ">>>": [">>>", "unsign_right_move\$"],
};

const Map<String, List<String>> specialOperatorList = {
  "[]": ["[]", "index\$"],
  "[]=": ["[]=", "index_set\$"]
};

abstract class Namer<T> {
  int index = 0;
  final Map<T, Name> map = <T, Name>{};

  Name getName(T key) => map.putIfAbsent(key, () => Name('$prefix${++index}'));

  String get prefix;

  void setParam(T key, String name, Object? value) {
    getName(key).params[name] = value;
  }

  Object? getParam(T key, String name) {
    return getName(key).params[name];
  }
}

class Name {
  final Map<String, Object?> params = {};
  final String text;

  Name(this.text);
}

class NormalNamer<T> extends Namer<T> {
  @override
  final String prefix;

  NormalNamer(this.prefix);
}

class NamedSystem {
  final Namer<String> _libraries = NormalNamer<String>('l');

  String coreLibraryName = "";

  String generate() {
    StringBuffer buffer = StringBuffer();
    _libraries.map.forEach((key, value) {
      buffer
          .write("import '${getLibraryNameFileName(key)}.g.dart' as $value;\n");
    });

    buffer.write(
        "import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;\n");
    buffer.write("import 'dart:typed_data';\n");
    buffer.write('''m.MicroDartEngine createMicroDartEngine(ByteData data) {
var engine = m.MicroDartEngine.fromData(data);
${_libraries.map.values.map((e) => "engine.addExternalFunctions($e.getLibrary(engine));\n").toList().join()}
return engine;
}

''');
    return buffer.toString();
  }

  String generate2() {
    final List<cb.Directive> importList = _libraries.map.entries
        .map<cb.Directive>((e) => cb.Directive.import(
            getLibraryNameFileName(e.key),
            as: e.value.text))
        .toList();
    final Map<String, cb.Expression> libraryMirrors = _libraries.map
        .map<String, cb.Expression>((key, value) =>
            MapEntry(key, cb.refer(value.text).property("libraryMirror")));

    var library = cb.Library((p0) => p0
      ..comments.add("generated by micro_dart_generator")
      ..directives.add(cb.Directive.import(
          "package:micro_dart_runtime/micro_dart_runtime.dart",
          as: "m"))
      ..directives.addAll(importList)
      ..body.add(cb.Field((p0) => p0
        ..name = 'libraryMirrors'
        ..modifier = cb.FieldModifier.constant
        ..assignment = cb
            .literalMap(
                libraryMirrors, cb.refer("String"), cb.refer("m.LibraryMirror"))
            .code)));
    return DartFormatter().format(library.accept(cb.DartEmitter()).toString());
  }

  String getLibraryName(String identifier) {
    var name = _libraries.getName(identifier);
    if (isCoreLibrary(identifier)) {
      coreLibraryName = name.text;
    }
    return name.text;
  }

  String getLibraryNameFileName(String identifier) {
    var s = identifier.split(":");
    var s2 = s[1].split("/");
    List<String> s3 = ["_"];

    s3.add(s[0]);
    s3.addAll(s2);

    var r = s3.join("_");
    if (!r.endsWith(".dart")) {
      r = "$r.dart";
    }
    return r;
  }

  bool isCoreLibrary(String identifier) {
    return identifier == "dart:core";
  }

  bool isCoreLibraryName(String name) {
    return name == coreLibraryName;
  }
}
