import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:code_builder/code_builder.dart' as cb;
import 'package:dart_style/dart_style.dart';

import 'abs_visitor.dart';
import 'code_gen_utils.dart';
import 'external_methods.dart';
import 'named_system.dart';
import 'overwrite_strategy.dart';
import 'extensions.dart';

class ClassItem {
  final String name;

  ClassItem(this.name);
  Map<String, cb.Expression> proxyGetterList = {};
  Map<String, cb.Expression> proxySetterList = {};
  //Map<String, cb.Expression> proxyConstructorList = {};
}

class CodeGenMirror extends AbsVisitor {
  final OverwriteStrategy overwriteStrategy;
  final NamedSystem namedSystem;
  final dartFormatter = DartFormatter();
  final dartEmitter = cb.DartEmitter();

  final Set<cb.Directive> importList = {};
  final Map<String, ClassItem> proxyClassList = {};
  final Map<String, cb.Expression> proxyGlobalGetterList = {};
  final Map<String, cb.Expression> proxyGlobalSetterList = {};

  final Set<cb.Method> proxyGlobalMethods = {};

  String? libraryName;

  ExternalMethods? externalMethods;

  CodeGenMirror(this.namedSystem, this.overwriteStrategy, this.externalMethods);

  String generate() {
    List<cb.Expression> positional = [];
    positional.add(cb.literalString(libraryName!));
    positional.add(cb.literalMap(proxyGlobalGetterList));
    positional.add(cb.literalMap(proxyGlobalSetterList));
    positional.add(
        cb.literalMap(proxyClassList.map<String, cb.Expression>((key, value) {
      List<cb.Expression> positional = [];
      positional.add(cb.literalString(key));
      //positional.add(cb.literalMap(value.proxyConstructorList));
      positional.add(cb.literalMap(value.proxyGetterList));
      positional.add(cb.literalMap(value.proxySetterList));
      return MapEntry(key, cb.refer("m.ClassMirror").call(positional));
    })));
    var library = cb.Library((p0) => p0
      ..comments.add("generated by micro_dart_generator")
      ..comments.add("ignore_for_file: non_constant_identifier_names")
      ..directives.add(cb.Directive.import(
          "package:micro_dart_runtime/micro_dart_runtime.dart",
          as: "m"))
      ..directives.addAll(importList)
      ..body.add(cb.Field((p0) => p0
        ..name = 'libraryMirror'
        ..modifier = cb.FieldModifier.constant
        ..assignment = cb.refer("m.LibraryMirror").call(positional).code))
      ..body.addAll(proxyGlobalMethods));

    try {
      return dartFormatter.format(library.accept(dartEmitter).toString());
    } catch (e, s) {
      print("$e  $s");
      return library.accept(dartEmitter).toString();
    }
    //return dartFormatter.format(library.accept(dartEmitter).toString());
  }

  @override
  void visitLibraryElement(LibraryElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.identifier)) {
      return;
    }

    namedSystem.getLibraryName(element.identifier);
    libraryName = element.identifier;
    if (!namedSystem.isCoreLibrary(element.identifier)) {
      importList.add(cb.Directive.import(element.identifier));
    }
    overwriteStrategy.libraryAddImports[element.identifier]?.forEach((element) {
      importList.add(cb.Directive.import(element[0],
          show: List<String>.from(element[1]),
          hide: List<String>.from(element[2])));
    });
    element.visitChildren(this);
  }

  @override
  void visitLibraryImportElement(LibraryImportElement element) {
    if (element.importedLibrary == null) {
      return;
    }
    if (element.importedLibrary!.identifier.startsWith("dart:_") ||
        element.importedLibrary!.identifier.startsWith("package:_")) {
      return;
    }

    if (overwriteStrategy.libraryIgnoreImports[element.library.identifier]
            ?.contains(element.importedLibrary!.identifier) ??
        false) {
      return;
    }

    if (!namedSystem.isCoreLibrary(element.importedLibrary!.identifier)) {
      Set<String> showList = {};
      Set<String> hideList = {};
      for (var element in element.combinators) {
        if (element is ShowElementCombinator) {
          showList.addAll(element.shownNames);
        } else if (element is HideElementCombinator) {
          hideList.addAll(element.hiddenNames);
        }
      }

      importList.add(cb.Directive.import(element.importedLibrary!.identifier,
          show: showList.toList(), hide: hideList.toList()));
    }
  }

  @override
  void visitConstructorElement(ConstructorElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
    if (element.enclosingElement is EnumElement) {
      return;
    }
    var classElement = element.enclosingElement as ClassElement;
    if (classElement.isAbstract && !element.isFactory) {
      return;
    }

    // var classItem =
    //     proxyClassList[constructorElement.enclosingElement.displayName];
    // if (classItem == null) {
    //   throw Exception(
    //       "not found classItem ${constructorElement.enclosingElement.displayName}");
    // }

    // functionElementWithFunctionType(constructorElement, true,
    //     (cb.Method method) {
    //   proxyGlobalMethods.add(method);
    //   classItem.proxyConstructorList[constructorElement.name] =
    //       cb.refer(constructorElement.proxyName!).expression;
    // });

    var name = "${classElement.name}.${element.name}";

    if (externalMethods != null &&
        !externalMethods!.hasStaticMethod(libraryName, name, false)) {
      if (libraryName == "package:flutter/src/widgets/framework.dart") {
        print(
            "visitConstructorElement 1 $libraryName ${classElement.name} $name ");
      }
      return;
    }

    if (hasFunctionTypeParams(element.type) || element.name.isEmpty) {
      functionElementWithFunctionType(element, true, (cb.Method method) {
        proxyGlobalMethods.add(method);
        proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
      });
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");
      p0.types.addAll(
          element.typeParameters.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.body = cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
  }

  @override
  void visitEnumElement(EnumElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
    if (externalMethods != null &&
        !externalMethods!.hasClass(libraryName, element.displayName)) {
      return;
    }
    proxyClassList[element.displayName] = ClassItem(element.displayName);
    element.visitChildren(this);
  }

  @override
  void visitFieldElement(FieldElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
  }

  @override
  void visitClassElement(ClassElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }

    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
    if (externalMethods != null &&
        !externalMethods!.hasClass(libraryName, element.displayName)) {
      element.visitChildren(this);
      //print(
      //    "visitClassElement !hasClass $libraryName  ${element.displayName} ${externalMethods?.hasClass(libraryName, element.displayName)}");
      return;
    }
    proxyClassList[element.displayName] = ClassItem(element.displayName);
    final asKey = "${element.key}@#as";
    final isKey = "${element.key}@#is";
    if (!overwriteStrategy.ignoreKeys.contains(asKey)) {
      if (externalMethods != null &&
          !externalMethods!
              .hasMethod(libraryName, element.displayName, "#as", false)) {
      } else {
        writeTargetKeywordClassName(element, "#as");
      }
    }
    if (!overwriteStrategy.ignoreKeys.contains(isKey)) {
      if (externalMethods != null &&
          !externalMethods!
              .hasMethod(libraryName, element.displayName, "#is", false)) {
      } else {
        writeTargetKeywordClassName(element, "#is");
      }
    }

    element.visitChildren(this);
  }

  void writeTargetKeywordClassName(ClassElement classElement, String keyword) {
    var type = classElement.thisType;
    var classItem = proxyClassList[classElement.name];
    if (classItem == null) {
      return;
    }
    var proxyName = "${classElement.name}_${binaryOperatorList[keyword]![0]}\$";
    var method = cb.Method(((p0) {
      p0.name = proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      typeParams.addAll(classElement.typeParameters);

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer("dynamic");
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.lambda = true;
          p0.body = cb.Code(
              "target\$ ${binaryOperatorList[keyword]![0]} ${dartTypeToClassName3(type)}");
        },
      ).closure.code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[keyword] = cb.refer(proxyName).expression;
  }

  void addParameter(
      ParameterElement element,
      List<cb.Parameter> list,
      int index,
      bool toFunctionPointer,
      String? pre,
      List<TypeParameterElement> typeParameters) {
    list.add(cb.Parameter(
      (p0) {
        p0.named = element.isNamed;
        var name = element.name;
        if (name.isEmpty) {
          name = "\$p$index";
        }
        if (pre != null && element.isPositional) {
          name = "${pre}_$name\$";
        }
        p0.name = name;
        var typeString = dartTypeToClassName2(element.type, typeParameters,
            toFunctionPointer: toFunctionPointer);

        if (typeString == "void") {
          typeString = "dynamic";
        }

        if (element.hasDefaultValue && !typeString.endsWith("?")) {
          typeString = "$typeString?";
        } else if (element.isOptionalPositional && !typeString.endsWith("?")) {
          typeString = "$typeString?";
        } else if (element.isRequiredNamed) {
          p0.required = true;
        } else if (element.isNamed && !typeString.endsWith("?")) {
          typeString = "$typeString?";
        }

        p0.type = cb.refer(typeString);
      },
    ));
  }

  void functionElementWithFunctionType(ExecutableElement functionElement,
      bool isStatic, void Function(cb.Method method) callback) {
    List<cb.Parameter> requiredParameters = [];
    List<cb.Parameter> optionalParameters = [];

    var typeParameters = getTypeParameterElementWithoutDynamic(functionElement);

    for (int i = 0; i < functionElement.parameters.length; i++) {
      var parameter = functionElement.parameters[i];
      if (parameter.isPositional) {
        if (parameter.isOptionalPositional) {
          addParameter(
              parameter, optionalParameters, i, true, null, typeParameters);
        } else {
          addParameter(
              parameter, requiredParameters, i, true, null, typeParameters);
        }
      } else if (parameter.isNamed) {
        addParameter(
            parameter, optionalParameters, i, true, null, typeParameters);
      }
    }
    var classElement = functionElement.enclosingElement;
    var method = cb.Method(((p0) {
      p0.name = functionElement.proxyName;
      p0.returns = cb.refer("Function");
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      if (!isStatic) {
        classElement as InterfaceElement;
        var type = classElement.thisType;
        p0.requiredParameters.add(cb.Parameter(
          (p0) {
            p0.name = "target\$";
            p0.type = cb.refer(dartTypeTargetClassName(type, []));
          },
        ));
      }

      p0.lambda = true;
      var method = cb.Method(
        (p1) {
          p1.types.addAll(
              typeParameters.map<cb.TypeReference>((e) => cb.TypeReference(
                    (p2) {
                      p2.symbol = e.name;
                      if (e.bound != null) {
                        p2.bound = cb.refer(e.bound.toString());
                      }
                    },
                  )));

          p1.requiredParameters.addAll(requiredParameters);
          p1.optionalParameters.addAll(optionalParameters);
          p1.body = functionBody(functionElement, typeParameters);
        },
      ).genericClosure.code;
      p0.body = method; //cb.Code(method.accept(dartEmitter).toString());
    }));

    callback(method);
  }

  cb.Code functionBody(ExecutableElement functionElement,
      List<TypeParameterElement> typeParameters) {
    List<ParameterElement> positional = [];
    List<ParameterElement> optionalPositional = [];
    List<ParameterElement> named = [];
    List<ParameterElement> globalFunctionParams = [];
    var functionType = functionElement.type;
    for (int i = 0; i < functionType.parameters.length; i++) {
      var parameter = functionType.parameters[i];
      if (parameter.isPositional) {
        if (parameter.isOptionalPositional) {
          optionalPositional.add(parameter);
        } else {
          positional.add(parameter);
        }
      } else if (parameter.isNamed) {
        named.add(parameter);
      }
      if (isFunctionType(parameter.type)) {
        if (!parameter.isOptionalPositional) {
          globalFunctionParams.add(parameter);
        }
      }
    }

    List<cb.Code> statements = [];
    for (var parameter in globalFunctionParams) {
      writeFunctionParameterProxy(functionElement, parameter, statements);
    }

    if (optionalPositional.isNotEmpty) {
      ParameterElement? functionParam;
      List<ParameterElement> optionalPositional2 =
          List.from(optionalPositional);
      writeOptionalIfNull(optionalPositional, statements, () {
        writeFunctionBodyWithFunctionPointer(
            functionElement, positional, named, typeParameters, statements);
      });
      var ite = optionalPositional.iterator;
      while (ite.moveNext()) {
        var parameter = ite.current;
        positional.add(parameter);
        optionalPositional2.remove(parameter);
        if (isFunctionType(parameter.type)) {
          functionParam = parameter;
        } else {
          functionParam = null;
        }
        if (functionParam != null) {
          writeFunctionParameterProxy(
              functionElement, functionParam, statements);
        }
        if (optionalPositional2.isNotEmpty) {
          writeOptionalIfNull(optionalPositional2, statements, () {
            writeFunctionBodyWithFunctionPointer(
                functionElement, positional, named, typeParameters, statements);
          });
        } else {
          writeFunctionBodyWithFunctionPointer(
              functionElement, positional, named, typeParameters, statements);
        }

        if (functionType.returnType is VoidType) {
          statements.add(cb.Code("return;"));
        }
      }
    } else {
      writeFunctionBodyWithFunctionPointer(
          functionElement, positional, named, typeParameters, statements);
    }

    return cb.Block.of(statements);
  }

  void writeFunctionBodyWithFunctionPointer(
      ExecutableElement functionElement,
      List<ParameterElement> positional,
      List<ParameterElement> named,
      List<TypeParameterElement> typeParameters,
      List<cb.Code> list) {
    var functionType = functionElement.type;
    bool hasReturn = (functionType.returnType is! VoidType);

    var className = "";
    var name = functionElement.name;
    if (functionElement is PropertyAccessorElement ||
        functionElement is MethodElement) {
      if (functionElement.isStatic) {
        className = functionElement.enclosingElement.displayName;
      } else {
        className = "target\$";
      }
    }

    if (className.isNotEmpty) {
      name = "$className.$name";
    }

    if (functionElement is ConstructorElement) {
      if (name.isEmpty) {
        name = dartTypeTargetClassName(
            functionElement.enclosingElement.thisType, typeParameters);
      } else {
        name = dartTypeTargetClassName(
            functionElement.enclosingElement.thisType, typeParameters);
        name = "$name.${functionElement.name}";
      }
    }

    if (hasReturn) {
      name = "return $name";
    }

    var positionalList = positional.map<cb.Expression>((e) {
      var n = transformParameterName(functionElement, e, overwriteStrategy);

      return cb.refer(n).expression;
    }).toList();

    var nameMap = Map<String, cb.Expression>.fromIterable(
      named,
      key: (e) {
        return e.name;
      },
      value: (e) {
        e as ParameterElement;
        var name =
            transformParameterName(functionElement, e, overwriteStrategy);
        return cb.refer(name).expression;
      },
    );

    // var typeArguments = functionElement.typeParameters
    //     .map<cb.Reference>((e) => cb.refer(e.name))
    //     .toList();

    list.add(cb.refer(name).call(positionalList, nameMap).statement);
  }

  String? getDefaultValueCode(ParameterElement element) {
    var parentElement = element.enclosingElement;
    String? key;
    if (parentElement is ConstructorElement ||
        parentElement is MethodElement ||
        parentElement is FunctionElement) {
      key = parentElement?.key;
    }

    if (key != null && element.defaultValueCode != null) {
      Map? map = overwriteStrategy.defaultValueCodeOverwrites[key];
      if (map != null && map.containsKey(element.defaultValueCode)) {
        return map[element.defaultValueCode];
      }
    }

    return element.defaultValueCode;
  }

  void writeOptionalIfNull(List<ParameterElement> optionalPositionals,
      List<cb.Code> list, void Function() callback) {
    if (optionalPositionals.isEmpty) {
      return;
    }
    list.add(const cb.Code('if ('));
    for (int i = 0; i < optionalPositionals.length; i++) {
      list.add(
          cb.refer(optionalPositionals[i].name).equalTo(cb.literalNull).code);
      if (i < optionalPositionals.length - 1) {
        list.add(const cb.Code(' && '));
      }
    }

    list.add(const cb.Code(') {'));
    callback();
    list.add(const cb.Code('}'));
  }

  void writeFunctionParameterProxy(ExecutableElement functionElement,
      ParameterElement parameterElement, List<cb.Code> list) {
    var type = parameterElement.type as FunctionType;
    var name = parameterElement.name;
    var proxyName = "${name}Proxy";
    bool isAsync = (type.returnType.isDartAsyncFuture ||
        type.returnType.isDartAsyncFutureOr);

    List<cb.Parameter> requiredParameters = [];
    List<cb.Parameter> optionalParameters = [];

    for (int i = 0; i < type.parameters.length; i++) {
      var parameter = type.parameters[i];
      if (parameter.isPositional) {
        if (parameter.isOptionalPositional) {
          addParameter(
              parameter, optionalParameters, i, false, null, type.typeFormals);
        } else {
          addParameter(
              parameter, requiredParameters, i, false, name, type.typeFormals);
        }
      } else if (parameter.isNamed) {
        addParameter(
            parameter, optionalParameters, i, false, null, type.typeFormals);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = proxyName;
      p0.modifier = isAsync ? cb.MethodModifier.async : null;

      p0.types.addAll(
          type.typeFormals.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer(dartTypeToProxyReturn(
          parameterElement, type.returnType, type.typeFormals));
      p0.optionalParameters.addAll(optionalParameters);
      p0.requiredParameters.addAll(requiredParameters);
      p0.lambda = true;
      p0.body = functionProxyBody(functionElement, parameterElement);
    }));

    list.add(cb.Code(method.accept(dartEmitter).toString()));
  }

  cb.Code functionProxyBody(
      ExecutableElement functionElement, ParameterElement parameterElement) {
    var type = parameterElement.type as FunctionType;

    bool isAsync = (type.returnType.isDartAsyncFuture ||
        type.returnType.isDartAsyncFutureOr);
    var callFunctionPointer = "callFunctionPointer";
    var scope = "scope\$";
    if (isAsync) {
      scope = "await scope\$";
      callFunctionPointer = "callFunctionPointerAsync";
    }
    var pointerName = parameterElement.name;
    if (type.nullabilitySuffix == NullabilitySuffix.question ||
        parameterElement.hasDefaultValue) {
      pointerName = "$pointerName!";
    }
    List<cb.Reference> positionalArguments = [];
    Map<String, cb.Reference> namedArguments = {};

    for (int i = 0; i < type.parameters.length; i++) {
      if (type.parameters[i].isNamed) {
        var name = type.parameters[i].name;
        if (name.isEmpty) {
          name = "\$p$i";
        }
        namedArguments[name] = cb.refer(name);
      } else if (type.parameters[i].isPositional) {
        var name = type.parameters[i].name;
        if (name.isEmpty) {
          name = "\$p$i";
        }
        if (!type.parameters[i].isOptionalPositional) {
          name = "${parameterElement.name}_$name\$";
        }
        positionalArguments.add(cb.refer(name));
      }
    }
    return cb
        .refer(scope)
        .property("engine")
        .property(callFunctionPointer)
        .call([
      cb.refer("scope\$"),
      cb.refer(pointerName),
      cb.literalList(positionalArguments),
      cb.literalMap(namedArguments)
    ]).statement;
  }

  @override
  void visitFunctionElement(FunctionElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }

    if (externalMethods != null &&
        !externalMethods!.hasStaticMethod(libraryName, element.name, false)) {
      if (libraryName == "package:flutter/src/widgets/framework.dart") {
        print("visitFunctionElement $libraryName ${element.name}");
      }
      return;
    }

    if (hasFunctionTypeParams(element.type)) {
      functionElementWithFunctionType(element, true, (cb.Method method) {
        proxyGlobalMethods.add(method);
        var name = element.getNameWithClass();
        proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
      });
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");
      p0.types.addAll(
          element.typeParameters.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.body = cb.TypeReference(
        (p0) {
          p0.symbol = element.name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeSpecialMethodElement(MethodElement element) {
    var name = "target\$.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer(dartTypeToClassName3(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.requiredParameters.add(cb.Parameter(
            (p0) {
              p0.name = "index";
              p0.type = cb.refer(dartTypeToClassName3(
                  element.parameters[0].type,
                  toFunctionPointer: false));
            },
          ));

          if (element.name == "[]=") {
            p0.requiredParameters.add(cb.Parameter(
              (p0) {
                p0.name = "other";
                p0.type = cb.refer(dartTypeToClassName3(
                    element.parameters[1].type,
                    toFunctionPointer: false));
              },
            ));
          }

          p0.lambda = true;
          if (element.name == "[]") {
            p0.body = cb.Code("target\$[index]");
          } else if (element.name == "[]=") {
            p0.body = cb.Code("target\$[index]=other");
          }
        },
      ).closure.code;

      cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeUnaryMethodElement(MethodElement element) {
    var name = "target\$.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer(dartTypeToClassName3(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.lambda = true;
          p0.body = cb.Code(" ${unaryOperatorList[element.name]![0]} target\$");
        },
      ).closure.code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeBinaryMethodElement(MethodElement element) {
    var name = "target\$.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer(dartTypeToClassName3(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.requiredParameters.add(cb.Parameter(
            (p0) {
              p0.name = "other\$";
              p0.type = cb.refer(dartTypeToClassName3(
                  element.parameters[0].type,
                  toFunctionPointer: false));
            },
          ));

          p0.lambda = true;
          p0.body = cb.Code(
              "target\$ ${binaryOperatorList[element.name]![0]} other\$");
        },
      ).closure.code;

      cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  @override
  void visitMethodElement(MethodElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
    var classElement = element.enclosingElement as InterfaceElement;
    if (externalMethods != null) {
      if (element.isStatic) {
        if (!externalMethods!
            .hasStaticMethod(libraryName, element.getNameWithClass(), false)) {
          if (libraryName == "package:flutter/src/widgets/framework.dart") {
            print(
                "visitMethodElement $libraryName ${element.getNameWithClass()}");
          }
          return;
        }
      } else {
        if (!externalMethods!.hasMethod(libraryName,
            element.enclosingElement.displayName, element.name, false)) {
          return;
        }
      }
    }
    var name = element.name;
    if (binaryOperatorList.containsKey(name)) {
      writeBinaryMethodElement(element);
      return;
    } else if (unaryOperatorList.containsKey(name)) {
      writeUnaryMethodElement(element);
      return;
    } else if (specialOperatorList.containsKey(name)) {
      writeSpecialMethodElement(element);
      return;
    }

    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];

    if (hasFunctionTypeParams(element.type)) {
      functionElementWithFunctionType(element, element.isStatic,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        var name = element.name;
        if (classItem == null) {
          return;
        }
        classItem.proxyGetterList[name] =
            cb.refer(element.proxyName!).expression;
      });
      return;
    }

    if (element.isStatic) {
      name = element.getNameWithClass();
    } else {
      name = "target\$.${element.name}";
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      if (!element.isStatic) {
        p0.requiredParameters.add(cb.Parameter(
          (p0) {
            p0.name = "target\$";
            p0.type = cb.refer(dartTypeTargetClassName(type, typeParams));
          },
        ));
      }

      p0.body = cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    if (element.isStatic) {
      proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
    } else {
      if (classItem == null) {
        return;
      }
      classItem.proxyGetterList[element.name] =
          cb.refer(element.proxyName!).expression;
    }
  }

  @override
  void visitPropertyAccessorElement(PropertyAccessorElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ignoreKeys.contains(element.key)) {
      return;
    }
    if (element.isStatic) {
      writeStaticProperty(element);
    } else {
      writeClassProperty(element);
    }
  }

  void writeStaticProperty(PropertyAccessorElement element) {
    if (element.isGetter) {
      writeStaticPropertyGetter(element);
    } else if (element.isSetter) {
      writeStaticPropertySetter(element);
    }
  }

  void writeClassProperty(PropertyAccessorElement element) {
    if (element.isGetter) {
      writeClassPropertyGetter(element);
    } else if (element.isSetter) {
      writeClassPropertySetter(element);
    }
  }

  void writeStaticPropertyGetter(PropertyAccessorElement element) {
    var name = element.getNameWithClass();

    if (externalMethods != null) {
      if (!externalMethods!.hasStaticMethod(libraryName, name, false)) {
        if (libraryName == "dart:core") {
          print("visitFunctionElement $libraryName $name");
        }
        return;
      }
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.body = cb.Method(
        (p0) {
          p0.lambda = true;
          p0.body = cb.Code(name);
        },
      ).closure.code;
    }));

    proxyGlobalMethods.add(method);
    proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
  }

  void writeStaticPropertySetter(
      PropertyAccessorElement propertyAccessorElement) {
    var name = propertyAccessorElement.getNameWithClass();

    if (externalMethods != null) {
      if (!externalMethods!.hasStaticMethod(libraryName, name, true)) {
        if (libraryName == "dart:core") {
          print("visitFunctionElement $libraryName $name");
        }
        return;
      }
    }

    if (hasFunctionTypeParams(propertyAccessorElement.type)) {
      functionElementWithFunctionType(propertyAccessorElement, true,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        proxyGlobalSetterList[propertyAccessorElement.getNameWithClass()] =
            cb.refer(propertyAccessorElement.proxyName!).expression;
      });
      return;
    }

    List<cb.Parameter> requiredParameters = [];

    for (int i = 0; i < propertyAccessorElement.type.parameters.length; i++) {
      if (propertyAccessorElement.type.parameters[i].isRequired) {
        addParameter(
            propertyAccessorElement.type.parameters[i],
            requiredParameters,
            i,
            true,
            null,
            propertyAccessorElement.typeParameters);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = propertyAccessorElement.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "other\$";
          p0.type = requiredParameters.first.type;
        },
      ));
      p0.types.addAll(propertyAccessorElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer("void");
      p0.lambda = false;
      p0.body = cb.refer(name).assign(cb.refer("other\$")).statement;
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalSetterList[name] =
        cb.refer(propertyAccessorElement.proxyName!).expression;
  }

  void writeClassPropertyGetter(PropertyAccessorElement element) {
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      return;
    }
    var name = "target\$.${element.displayName}";

    if (externalMethods != null) {
      if (!externalMethods!.hasMethod(libraryName,
          element.enclosingElement.displayName, element.displayName, false)) {
        return;
      }
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer(
              dartTypeTargetClassName(type, classElement.typeParameters));
        },
      ));
      p0.types.addAll(classElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer("Function");
      // var returnType = element.returnType;
      // if (returnType is InterfaceType) {
      //   if (returnType.element.isPrivate) {
      //     p0.returns = cb.refer("dynamic");
      //   } else {
      //     p0.returns = cb.refer(
      //         dartTypeTargetClassName(returnType, classElement.typeParameters));
      //   }
      // } else {
      //   p0.returns = cb
      //       .refer(dartTypeToClassName3(returnType, toFunctionPointer: false));
      // }

      var method = cb.Method(
        (p1) {
          p1.body = cb.Block.of([
            cb.Code("return "),
            cb.TypeReference(
              (p0) {
                p0.symbol = name;
                p0.types.addAll(element.typeParameters
                    .map<cb.TypeReference>((e) => cb.TypeReference(
                          (p0) {
                            p0.symbol = e.name;
                          },
                        )));
              },
            ).statement
          ]);
        },
      ).genericClosure.code;

      p0.body = method;
    }));

    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.displayName] =
        cb.refer(element.proxyName!).expression;
  }

  void writeClassPropertySetter(
      PropertyAccessorElement propertyAccessorElement) {
    var classElement =
        propertyAccessorElement.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem =
        proxyClassList[propertyAccessorElement.enclosingElement.displayName];
    if (classItem == null) {
      return;
    }
    var name = "target\$.${propertyAccessorElement.displayName}";

    if (externalMethods != null) {
      if (!externalMethods!.hasMethod(
          libraryName,
          propertyAccessorElement.enclosingElement.displayName,
          propertyAccessorElement.displayName,
          true)) {
        return;
      }
    }

    if (hasFunctionTypeParams(propertyAccessorElement.type)) {
      functionElementWithFunctionType(propertyAccessorElement, false,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        classItem.proxySetterList[propertyAccessorElement.displayName] =
            cb.refer(propertyAccessorElement.proxyName!).expression;
      });
      return;
    }

    List<cb.Parameter> requiredParameters = [];

    for (int i = 0; i < propertyAccessorElement.type.parameters.length; i++) {
      if (propertyAccessorElement.type.parameters[i].isRequired) {
        addParameter(propertyAccessorElement.type.parameters[i],
            requiredParameters, i, true, null, classElement.typeParameters);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = propertyAccessorElement.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope\$";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target\$";
          p0.type = cb.refer(dartTypeTargetClassName(type, []));
        },
      ));

      p0.types.addAll(classElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer("void");
      p0.lambda = true;

      var method = cb.Method(
        (p1) {
          p1.requiredParameters.add(cb.Parameter(
            (p0) {
              p0.name = "other\$";
              p0.type = cb.refer("dynamic");
            },
          ));
          p1.body = cb.refer(name).assign(cb.refer("other\$")).statement;
        },
      ).genericClosure.code;

      p0.body = method;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxySetterList[propertyAccessorElement.displayName] =
        cb.refer(propertyAccessorElement.proxyName!).expression;
  }
}
