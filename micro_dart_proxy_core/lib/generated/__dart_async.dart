// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:async';
import 'dart:collection' show HashMap;

const libraryMirror = m.LibraryMirror(
  'dart:async',
  {
    'AsyncError.': _AsyncError__$,
    'AsyncError.defaultStackTrace': _AsyncError_defaultStackTrace$,
    'DeferredLoadException.': _DeferredLoadException__$,
    'Future.': _Future__$,
    'Future.microtask': _Future_microtask_$,
    'Future.sync': _Future_sync_$,
    'Future.value': _Future_value_$,
    'Future.error': _Future_error_$,
    'Future.delayed': _Future_delayed_$,
    'Future.any': _Future_any$,
    'TimeoutException.': _TimeoutException__$,
    'Completer.': _Completer__$,
    'Completer.sync': _Completer_sync_$,
    'unawaited': _unawaited$,
    'ParallelWaitError.': _ParallelWaitError__$,
    'scheduleMicrotask': _scheduleMicrotask$,
    'Stream.empty': _Stream_empty_$,
    'Stream.value': _Stream_value_$,
    'Stream.error': _Stream_error_$,
    'Stream.fromFuture': _Stream_fromFuture_$,
    'Stream.fromFutures': _Stream_fromFutures_$,
    'Stream.fromIterable': _Stream_fromIterable_$,
    'Stream.multi': _Stream_multi_$,
    'Stream.periodic': _Stream_periodic_$,
    'Stream.eventTransformed': _Stream_eventTransformed_$,
    'Stream.castFrom': _Stream_castFrom$,
    'StreamView.': _StreamView__$,
    'StreamTransformer.': _StreamTransformer__$,
    'StreamTransformer.fromHandlers': _StreamTransformer_fromHandlers_$,
    'StreamTransformer.fromBind': _StreamTransformer_fromBind_$,
    'StreamTransformer.castFrom': _StreamTransformer_castFrom$,
    'StreamIterator.': _StreamIterator__$,
    'StreamController.': _StreamController__$,
    'StreamController.broadcast': _StreamController_broadcast_$,
    'Timer.': _Timer__$,
    'Timer.periodic': _Timer_periodic_$,
    'ZoneSpecification.': _ZoneSpecification__$,
    'ZoneSpecification.from': _ZoneSpecification_from_$,
    'Zone.root': _Zone_root$,
    'Zone.current': _Zone_current$,
    'runZoned': _runZoned$,
    'runZonedGuarded': _runZonedGuarded$,
  },
  {},
  {
    'AsyncError': m.ClassMirror(
      'AsyncError',
      {
        '#as': AsyncError_as$,
        '#is': AsyncError_is$,
        'error': _AsyncError_error$,
        'stackTrace': _AsyncError_stackTrace$,
        'toString': _AsyncError_toString$,
      },
      {},
    ),
    'DeferredLoadException': m.ClassMirror(
      'DeferredLoadException',
      {
        '#as': DeferredLoadException_as$,
        '#is': DeferredLoadException_is$,
        'toString': _DeferredLoadException_toString$,
      },
      {},
    ),
    'FutureOr': m.ClassMirror(
      'FutureOr',
      {
        '#as': FutureOr_as$,
        '#is': FutureOr_is$,
      },
      {},
    ),
    'Future': m.ClassMirror(
      'Future',
      {
        '#as': Future_as$,
        '#is': Future_is$,
        'wait': _Future_wait$,
        'forEach': _Future_forEach$,
        'doWhile': _Future_doWhile$,
        'then': _Future_then$,
        'catchError': _Future_catchError$,
        'whenComplete': _Future_whenComplete$,
        'asStream': _Future_asStream$,
        'timeout': _Future_timeout$,
      },
      {},
    ),
    'TimeoutException': m.ClassMirror(
      'TimeoutException',
      {
        '#as': TimeoutException_as$,
        '#is': TimeoutException_is$,
        'message': _TimeoutException_message$,
        'duration': _TimeoutException_duration$,
        'toString': _TimeoutException_toString$,
      },
      {},
    ),
    'Completer': m.ClassMirror(
      'Completer',
      {
        '#as': Completer_as$,
        '#is': Completer_is$,
        'future': _Completer_future$,
        'isCompleted': _Completer_isCompleted$,
        'complete': _Completer_complete$,
        'completeError': _Completer_completeError$,
      },
      {},
    ),
    'ParallelWaitError': m.ClassMirror(
      'ParallelWaitError',
      {
        '#as': ParallelWaitError_as$,
        '#is': ParallelWaitError_is$,
        'values': _ParallelWaitError_values$,
        'errors': _ParallelWaitError_errors$,
        'toString': _ParallelWaitError_toString$,
      },
      {},
    ),
    'Stream': m.ClassMirror(
      'Stream',
      {
        '#as': Stream_as$,
        '#is': Stream_is$,
        'isBroadcast': _Stream_isBroadcast$,
        'length': _Stream_length$,
        'isEmpty': _Stream_isEmpty$,
        'first': _Stream_first$,
        'last': _Stream_last$,
        'single': _Stream_single$,
        'asBroadcastStream': _Stream_asBroadcastStream$,
        'listen': _Stream_listen$,
        'where': _Stream_where$,
        'map': _Stream_map$,
        'asyncMap': _Stream_asyncMap$,
        'asyncExpand': _Stream_asyncExpand$,
        'handleError': _Stream_handleError$,
        'expand': _Stream_expand$,
        'pipe': _Stream_pipe$,
        'transform': _Stream_transform$,
        'reduce': _Stream_reduce$,
        'fold': _Stream_fold$,
        'join': _Stream_join$,
        'contains': _Stream_contains$,
        'forEach': _Stream_forEach$,
        'every': _Stream_every$,
        'any': _Stream_any$,
        'cast': _Stream_cast$,
        'toList': _Stream_toList$,
        'toSet': _Stream_toSet$,
        'drain': _Stream_drain$,
        'take': _Stream_take$,
        'takeWhile': _Stream_takeWhile$,
        'skip': _Stream_skip$,
        'skipWhile': _Stream_skipWhile$,
        'distinct': _Stream_distinct$,
        'firstWhere': _Stream_firstWhere$,
        'lastWhere': _Stream_lastWhere$,
        'singleWhere': _Stream_singleWhere$,
        'elementAt': _Stream_elementAt$,
        'timeout': _Stream_timeout$,
      },
      {},
    ),
    'StreamSubscription': m.ClassMirror(
      'StreamSubscription',
      {
        '#as': StreamSubscription_as$,
        '#is': StreamSubscription_is$,
        'isPaused': _StreamSubscription_isPaused$,
        'cancel': _StreamSubscription_cancel$,
        'onData': _StreamSubscription_onData$,
        'onError': _StreamSubscription_onError$,
        'onDone': _StreamSubscription_onDone$,
        'pause': _StreamSubscription_pause$,
        'resume': _StreamSubscription_resume$,
        'asFuture': _StreamSubscription_asFuture$,
      },
      {},
    ),
    'EventSink': m.ClassMirror(
      'EventSink',
      {
        '#as': EventSink_as$,
        '#is': EventSink_is$,
        'add': _EventSink_add$,
        'addError': _EventSink_addError$,
        'close': _EventSink_close$,
      },
      {},
    ),
    'StreamView': m.ClassMirror(
      'StreamView',
      {
        '#as': StreamView_as$,
        '#is': StreamView_is$,
        'isBroadcast': _StreamView_isBroadcast$,
        'asBroadcastStream': _StreamView_asBroadcastStream$,
        'listen': _StreamView_listen$,
      },
      {},
    ),
    'StreamConsumer': m.ClassMirror(
      'StreamConsumer',
      {
        '#as': StreamConsumer_as$,
        '#is': StreamConsumer_is$,
        'addStream': _StreamConsumer_addStream$,
        'close': _StreamConsumer_close$,
      },
      {},
    ),
    'StreamSink': m.ClassMirror(
      'StreamSink',
      {
        '#as': StreamSink_as$,
        '#is': StreamSink_is$,
        'done': _StreamSink_done$,
        'close': _StreamSink_close$,
      },
      {},
    ),
    'StreamTransformer': m.ClassMirror(
      'StreamTransformer',
      {
        '#as': StreamTransformer_as$,
        '#is': StreamTransformer_is$,
        'bind': _StreamTransformer_bind$,
        'cast': _StreamTransformer_cast$,
      },
      {},
    ),
    'StreamTransformerBase': m.ClassMirror(
      'StreamTransformerBase',
      {
        '#as': StreamTransformerBase_as$,
        '#is': StreamTransformerBase_is$,
        'cast': _StreamTransformerBase_cast$,
      },
      {},
    ),
    'StreamIterator': m.ClassMirror(
      'StreamIterator',
      {
        '#as': StreamIterator_as$,
        '#is': StreamIterator_is$,
        'current': _StreamIterator_current$,
        'moveNext': _StreamIterator_moveNext$,
        'cancel': _StreamIterator_cancel$,
      },
      {},
    ),
    'MultiStreamController': m.ClassMirror(
      'MultiStreamController',
      {
        '#as': MultiStreamController_as$,
        '#is': MultiStreamController_is$,
        'addSync': _MultiStreamController_addSync$,
        'addErrorSync': _MultiStreamController_addErrorSync$,
        'closeSync': _MultiStreamController_closeSync$,
      },
      {},
    ),
    'StreamController': m.ClassMirror(
      'StreamController',
      {
        '#as': StreamController_as$,
        '#is': StreamController_is$,
        'onListen': _StreamController_onListen$,
        'onPause': _StreamController_onPause$,
        'onResume': _StreamController_onResume$,
        'onCancel': _StreamController_onCancel$,
        'stream': _StreamController_stream$,
        'sink': _StreamController_sink$,
        'isClosed': _StreamController_isClosed$,
        'isPaused': _StreamController_isPaused$,
        'hasListener': _StreamController_hasListener$,
        'done': _StreamController_done$,
        'add': _StreamController_add$,
        'addError': _StreamController_addError$,
        'close': _StreamController_close$,
        'addStream': _StreamController_addStream$,
      },
      {
        'onListen': _StreamController_onListen_set$,
        'onPause': _StreamController_onPause_set$,
        'onResume': _StreamController_onResume_set$,
        'onCancel': _StreamController_onCancel_set$,
      },
    ),
    'SynchronousStreamController': m.ClassMirror(
      'SynchronousStreamController',
      {
        '#as': SynchronousStreamController_as$,
        '#is': SynchronousStreamController_is$,
        'add': _SynchronousStreamController_add$,
        'addError': _SynchronousStreamController_addError$,
        'close': _SynchronousStreamController_close$,
      },
      {},
    ),
    'Timer': m.ClassMirror(
      'Timer',
      {
        '#as': Timer_as$,
        '#is': Timer_is$,
        'tick': _Timer_tick$,
        'isActive': _Timer_isActive$,
        'run': _Timer_run$,
        'cancel': _Timer_cancel$,
      },
      {},
    ),
    'ZoneSpecification': m.ClassMirror(
      'ZoneSpecification',
      {
        '#as': ZoneSpecification_as$,
        '#is': ZoneSpecification_is$,
        'handleUncaughtError': _ZoneSpecification_handleUncaughtError$,
        'run': _ZoneSpecification_run$,
        'runUnary': _ZoneSpecification_runUnary$,
        'runBinary': _ZoneSpecification_runBinary$,
        'registerCallback': _ZoneSpecification_registerCallback$,
        'registerUnaryCallback': _ZoneSpecification_registerUnaryCallback$,
        'registerBinaryCallback': _ZoneSpecification_registerBinaryCallback$,
        'errorCallback': _ZoneSpecification_errorCallback$,
        'scheduleMicrotask': _ZoneSpecification_scheduleMicrotask$,
        'createTimer': _ZoneSpecification_createTimer$,
        'createPeriodicTimer': _ZoneSpecification_createPeriodicTimer$,
        'print': _ZoneSpecification_print$,
        'fork': _ZoneSpecification_fork$,
      },
      {},
    ),
    'ZoneDelegate': m.ClassMirror(
      'ZoneDelegate',
      {
        '#as': ZoneDelegate_as$,
        '#is': ZoneDelegate_is$,
        'handleUncaughtError': _ZoneDelegate_handleUncaughtError$,
        'run': _ZoneDelegate_run$,
        'runUnary': _ZoneDelegate_runUnary$,
        'runBinary': _ZoneDelegate_runBinary$,
        'registerCallback': _ZoneDelegate_registerCallback$,
        'registerUnaryCallback': _ZoneDelegate_registerUnaryCallback$,
        'registerBinaryCallback': _ZoneDelegate_registerBinaryCallback$,
        'errorCallback': _ZoneDelegate_errorCallback$,
        'scheduleMicrotask': _ZoneDelegate_scheduleMicrotask$,
        'createTimer': _ZoneDelegate_createTimer$,
        'createPeriodicTimer': _ZoneDelegate_createPeriodicTimer$,
        'print': _ZoneDelegate_print$,
        'fork': _ZoneDelegate_fork$,
      },
      {},
    ),
    'Zone': m.ClassMirror(
      'Zone',
      {
        '#as': Zone_as$,
        '#is': Zone_is$,
        'parent': _Zone_parent$,
        'errorZone': _Zone_errorZone$,
        'handleUncaughtError': _Zone_handleUncaughtError$,
        'inSameErrorZone': _Zone_inSameErrorZone$,
        'fork': _Zone_fork$,
        'run': _Zone_run$,
        'runUnary': _Zone_runUnary$,
        'runBinary': _Zone_runBinary$,
        'runGuarded': _Zone_runGuarded$,
        'runUnaryGuarded': _Zone_runUnaryGuarded$,
        'runBinaryGuarded': _Zone_runBinaryGuarded$,
        'registerCallback': _Zone_registerCallback$,
        'registerUnaryCallback': _Zone_registerUnaryCallback$,
        'registerBinaryCallback': _Zone_registerBinaryCallback$,
        'bindCallback': _Zone_bindCallback$,
        'bindUnaryCallback': _Zone_bindUnaryCallback$,
        'bindBinaryCallback': _Zone_bindBinaryCallback$,
        'bindCallbackGuarded': _Zone_bindCallbackGuarded$,
        'bindUnaryCallbackGuarded': _Zone_bindUnaryCallbackGuarded$,
        'bindBinaryCallbackGuarded': _Zone_bindBinaryCallbackGuarded$,
        'errorCallback': _Zone_errorCallback$,
        'scheduleMicrotask': _Zone_scheduleMicrotask$,
        'createTimer': _Zone_createTimer$,
        'createPeriodicTimer': _Zone_createPeriodicTimer$,
        'print': _Zone_print$,
        '[]': _Zone_$index$$,
      },
      {},
    ),
  },
);
Function AsyncError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AsyncError;
Function AsyncError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AsyncError;
Function _AsyncError_error$(
  m.Scope scope$,
  AsyncError target$,
) =>
    () {
      return target$.error;
    };
Function _AsyncError_stackTrace$(
  m.Scope scope$,
  AsyncError target$,
) =>
    () {
      return target$.stackTrace;
    };
Function _AsyncError__$(m.Scope scope$) => (
      Object error,
      StackTrace? stackTrace,
    ) {
      return AsyncError(
        error,
        stackTrace,
      );
    };
Function _AsyncError_defaultStackTrace$(m.Scope scope$) =>
    AsyncError.defaultStackTrace;
Function _AsyncError_toString$(
  m.Scope scope$,
  AsyncError target$,
) =>
    target$.toString;
Function DeferredLoadException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DeferredLoadException;
Function DeferredLoadException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DeferredLoadException;
Function _DeferredLoadException__$(m.Scope scope$) => (String message) {
      return DeferredLoadException(message);
    };
Function _DeferredLoadException_toString$(
  m.Scope scope$,
  DeferredLoadException target$,
) =>
    target$.toString;
Function FutureOr_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FutureOr<T>;
Function FutureOr_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FutureOr<T>;
Function Future_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Future<T>;
Function Future_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Future<T>;
Function _Future__$(m.Scope scope$) => (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future(computationProxy);
    };
Function _Future_microtask_$(m.Scope scope$) =>
    (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future.microtask(computationProxy);
    };
Function _Future_sync_$(m.Scope scope$) => (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future.sync(computationProxy);
    };
Function _Future_value_$(m.Scope scope$) => Future.value;
Function _Future_error_$(m.Scope scope$) => Future.error;
Function _Future_delayed_$(m.Scope scope$) => (
      Duration duration, [
      m.FunctionPointer? computation,
    ]) {
      if (computation == null) {
        return Future.delayed(duration);
      }
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation!,
            [],
            {},
          );
      return Future.delayed(
        duration,
        computation == null ? null : computationProxy,
      );
    };
Function _Future_wait$(m.Scope scope$) => (
      Iterable futures, {
      bool? eagerError,
      m.FunctionPointer? cleanUp,
    }) {
      void cleanUpProxy(dynamic cleanUp_successValue$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            cleanUp!,
            [cleanUp_successValue$],
            {},
          );
      return Future.wait(
        Iterable.castFrom(futures),
        cleanUp: cleanUp == null ? null : cleanUpProxy,
        eagerError: eagerError ?? false,
      );
    };
Function _Future_any$<T>(m.Scope scope$) => Future.any<T>;
Function _Future_forEach$(m.Scope scope$) => (
      Iterable elements,
      m.FunctionPointer action,
    ) {
      FutureOr<dynamic> actionProxy(dynamic action_element$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [action_element$],
            {},
          );
      return Future.forEach(
        Iterable.castFrom(elements),
        actionProxy,
      );
    };
Function _Future_doWhile$(m.Scope scope$) => (m.FunctionPointer action) {
      FutureOr<bool> actionProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [],
            {},
          );
      return Future.doWhile(actionProxy);
    };
Function _Future_then$(
  m.Scope scope$,
  Future target$,
) =>
    (
      m.FunctionPointer onValue, {
      Function? onError,
    }) {
      FutureOr onValueProxy(dynamic onValue_value$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onValue,
            [onValue_value$],
            {},
          );
      return target$.then(
        onValueProxy,
        onError: onError,
      );
    };
Function _Future_catchError$(
  m.Scope scope$,
  Future target$,
) =>
    (
      Function onError, {
      m.FunctionPointer? test,
    }) {
      bool testProxy(Object test_error$) => scope$.engine.callFunctionPointer(
            scope$,
            test!,
            [test_error$],
            {},
          );
      return target$.catchError(
        onError,
        test: test == null ? null : testProxy,
      );
    };
Function _Future_whenComplete$(
  m.Scope scope$,
  Future target$,
) =>
    (m.FunctionPointer action) {
      FutureOr<void> actionProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [],
            {},
          );
      return target$.whenComplete(actionProxy);
    };
Function _Future_asStream$<T>(
  m.Scope scope$,
  Future<T> target$,
) =>
    target$.asStream;
Function _Future_timeout$(
  m.Scope scope$,
  Future target$,
) =>
    (
      Duration timeLimit, {
      m.FunctionPointer? onTimeout,
    }) {
      FutureOr onTimeoutProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onTimeout!,
            [],
            {},
          );
      return target$.timeout(
        timeLimit,
        onTimeout: onTimeout == null ? null : onTimeoutProxy,
      );
    };
Function TimeoutException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TimeoutException;
Function TimeoutException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TimeoutException;
Function _TimeoutException_message$(
  m.Scope scope$,
  TimeoutException target$,
) =>
    () {
      return target$.message;
    };
Function _TimeoutException_duration$(
  m.Scope scope$,
  TimeoutException target$,
) =>
    () {
      return target$.duration;
    };
Function _TimeoutException__$(m.Scope scope$) => (
      String? message, [
      Duration? duration,
    ]) {
      if (duration == null) {
        return TimeoutException(message);
      }
      return TimeoutException(
        message,
        duration!,
      );
    };
Function _TimeoutException_toString$(
  m.Scope scope$,
  TimeoutException target$,
) =>
    target$.toString;
Function Completer_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Completer<T>;
Function Completer_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Completer<T>;
Function _Completer_future$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    () {
      return target$.future;
    };
Function _Completer_isCompleted$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    () {
      return target$.isCompleted;
    };
Function _Completer__$(m.Scope scope$) => () {
      return Completer();
    };
Function _Completer_sync_$(m.Scope scope$) => Completer.sync;
Function _Completer_complete$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    target$.complete;
Function _Completer_completeError$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    target$.completeError;
Function _unawaited$(m.Scope scope$) => unawaited;
Function ParallelWaitError_as$<V, E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ParallelWaitError<V, E>;
Function ParallelWaitError_is$<V, E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ParallelWaitError<V, E>;
Function _ParallelWaitError_values$<V, E>(
  m.Scope scope$,
  ParallelWaitError<V, E> target$,
) =>
    () {
      return target$.values;
    };
Function _ParallelWaitError_errors$<V, E>(
  m.Scope scope$,
  ParallelWaitError<V, E> target$,
) =>
    () {
      return target$.errors;
    };
Function _ParallelWaitError__$(m.Scope scope$) => (
      dynamic values,
      dynamic errors,
    ) {
      return ParallelWaitError(
        values,
        errors,
      );
    };
Function _ParallelWaitError_toString$<V, E>(
  m.Scope scope$,
  ParallelWaitError<V, E> target$,
) =>
    target$.toString;
Function _scheduleMicrotask$(m.Scope scope$) => (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      scheduleMicrotask(callbackProxy);
    };
Function Stream_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Stream<T>;
Function Stream_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Stream<T>;
Function _Stream_isBroadcast$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.isBroadcast;
    };
Function _Stream_length$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.length;
    };
Function _Stream_isEmpty$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _Stream_first$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.first;
    };
Function _Stream_last$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.last;
    };
Function _Stream_single$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    () {
      return target$.single;
    };
Function _Stream_empty_$(m.Scope scope$) => Stream.empty;
Function _Stream_value_$(m.Scope scope$) => Stream.value;
Function _Stream_error_$(m.Scope scope$) => Stream.error;
Function _Stream_fromFuture_$(m.Scope scope$) => Stream.fromFuture;
Function _Stream_fromFutures_$(m.Scope scope$) => Stream.fromFutures;
Function _Stream_fromIterable_$(m.Scope scope$) => Stream.fromIterable;
Function _Stream_multi_$(m.Scope scope$) => (
      m.FunctionPointer onListen, {
      bool? isBroadcast,
    }) {
      void onListenProxy(MultiStreamController onListen_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen,
            [onListen_$p0$],
            {},
          );
      return Stream.multi(
        onListenProxy,
        isBroadcast: isBroadcast ?? false,
      );
    };
Function _Stream_periodic_$(m.Scope scope$) => (
      Duration period, [
      m.FunctionPointer? computation,
    ]) {
      if (computation == null) {
        return Stream.periodic(period);
      }
      dynamic computationProxy(int computation_computationCount$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            computation!,
            [computation_computationCount$],
            {},
          );
      return Stream.periodic(
        period,
        computation == null ? null : computationProxy,
      );
    };
Function _Stream_eventTransformed_$(m.Scope scope$) => (
      Stream<dynamic> source,
      m.FunctionPointer mapSink,
    ) {
      EventSink<dynamic> mapSinkProxy(EventSink mapSink_sink$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            mapSink,
            [mapSink_sink$],
            {},
          );
      return Stream.eventTransformed(
        source,
        mapSinkProxy,
      );
    };
Function _Stream_castFrom$<S, T>(m.Scope scope$) => Stream.castFrom<S, T>;
Function _Stream_asBroadcastStream$(
  m.Scope scope$,
  Stream target$,
) =>
    ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
    }) {
      void onCancelProxy(StreamSubscription onCancel_subscription$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [onCancel_subscription$],
            {},
          );
      void onListenProxy(StreamSubscription onListen_subscription$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [onListen_subscription$],
            {},
          );
      return target$.asBroadcastStream(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
      );
    };
Function _Stream_listen$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer? onData, {
      Function? onError,
      m.FunctionPointer? onDone,
      bool? cancelOnError,
    }) {
      void onDataProxy(dynamic onData_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onData!,
            [onData_event$],
            {},
          );
      void onDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDone!,
            [],
            {},
          );
      return target$.listen(
        onData == null ? null : onDataProxy,
        cancelOnError: cancelOnError,
        onDone: onDone == null ? null : onDoneProxy,
        onError: onError,
      );
    };
Function _Stream_where$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_event$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_event$],
            {},
          );
      return target$.where(testProxy);
    };
Function _Stream_map$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      dynamic convertProxy(dynamic convert_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [convert_event$],
            {},
          );
      return target$.map(convertProxy);
    };
Function _Stream_asyncMap$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      FutureOr convertProxy(dynamic convert_event$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            convert,
            [convert_event$],
            {},
          );
      return target$.asyncMap(convertProxy);
    };
Function _Stream_asyncExpand$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      Stream? convertProxy(dynamic convert_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [convert_event$],
            {},
          );
      return target$.asyncExpand(convertProxy);
    };
Function _Stream_handleError$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      Function onError, {
      m.FunctionPointer? test,
    }) {
      bool testProxy(dynamic test_error$) => scope$.engine.callFunctionPointer(
            scope$,
            test!,
            [test_error$],
            {},
          );
      return target$.handleError(
        onError,
        test: test == null ? null : testProxy,
      );
    };
Function _Stream_expand$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      Iterable convertProxy(dynamic convert_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [convert_element$],
            {},
          );
      return target$.expand(convertProxy);
    };
Function _Stream_pipe$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.pipe;
Function _Stream_transform$<T, S>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.transform<S>;
Function _Stream_reduce$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer combine) {
      dynamic combineProxy(
        dynamic combine_previous$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previous$,
              combine_element$,
            ],
            {},
          );
      return target$.reduce(combineProxy);
    };
Function _Stream_fold$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      dynamic initialValue,
      m.FunctionPointer combine,
    ) {
      dynamic combineProxy(
        dynamic combine_previous$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previous$,
              combine_element$,
            ],
            {},
          );
      return target$.fold(
        initialValue,
        combineProxy,
      );
    };
Function _Stream_join$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.join;
Function _Stream_contains$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.contains;
Function _Stream_forEach$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(dynamic action_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_element$],
            {},
          );
      return target$.forEach(actionProxy);
    };
Function _Stream_every$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.every(testProxy);
    };
Function _Stream_any$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.any(testProxy);
    };
Function _Stream_cast$<T, R>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.cast<R>;
Function _Stream_toList$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.toList;
Function _Stream_toSet$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.toSet;
Function _Stream_drain$<T, E>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.drain<E>;
Function _Stream_take$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.take;
Function _Stream_takeWhile$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.takeWhile(testProxy);
    };
Function _Stream_skip$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.skip;
Function _Stream_skipWhile$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.skipWhile(testProxy);
    };
Function _Stream_distinct$(
  m.Scope scope$,
  Stream target$,
) =>
    ([m.FunctionPointer? equals]) {
      if (equals == null) {
        return target$.distinct();
      }
      bool equalsProxy(
        dynamic equals_previous$,
        dynamic equals_next$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              equals_previous$,
              equals_next$,
            ],
            {},
          );
      return target$.distinct(equals == null ? null : equalsProxy);
    };
Function _Stream_firstWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.firstWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_lastWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.lastWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_singleWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_elementAt$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.elementAt;
Function _Stream_timeout$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      Duration timeLimit, {
      m.FunctionPointer? onTimeout,
    }) {
      void onTimeoutProxy(EventSink onTimeout_sink$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTimeout!,
            [onTimeout_sink$],
            {},
          );
      return target$.timeout(
        timeLimit,
        onTimeout: onTimeout == null ? null : onTimeoutProxy,
      );
    };
Function StreamSubscription_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamSubscription<T>;
Function StreamSubscription_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamSubscription<T>;
Function _StreamSubscription_isPaused$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    () {
      return target$.isPaused;
    };
Function _StreamSubscription_cancel$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.cancel;
Function _StreamSubscription_onData$(
  m.Scope scope$,
  StreamSubscription target$,
) =>
    (m.FunctionPointer? handleData) {
      void handleDataProxy(dynamic handleData_data$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleData!,
            [handleData_data$],
            {},
          );
      target$.onData(handleData == null ? null : handleDataProxy);
    };
Function _StreamSubscription_onError$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.onError;
Function _StreamSubscription_onDone$(
  m.Scope scope$,
  StreamSubscription target$,
) =>
    (m.FunctionPointer? handleDone) {
      void handleDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            handleDone!,
            [],
            {},
          );
      target$.onDone(handleDone == null ? null : handleDoneProxy);
    };
Function _StreamSubscription_pause$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.pause;
Function _StreamSubscription_resume$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.resume;
Function _StreamSubscription_asFuture$<T, E>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.asFuture<E>;
Function EventSink_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EventSink<T>;
Function EventSink_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EventSink<T>;
Function _EventSink_add$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.add;
Function _EventSink_addError$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.addError;
Function _EventSink_close$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.close;
Function StreamView_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamView<T>;
Function StreamView_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamView<T>;
Function _StreamView_isBroadcast$<T>(
  m.Scope scope$,
  StreamView<T> target$,
) =>
    () {
      return target$.isBroadcast;
    };
Function _StreamView__$(m.Scope scope$) => (Stream stream) {
      return StreamView(stream);
    };
Function _StreamView_asBroadcastStream$(
  m.Scope scope$,
  StreamView target$,
) =>
    ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
    }) {
      void onCancelProxy(StreamSubscription onCancel_subscription$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [onCancel_subscription$],
            {},
          );
      void onListenProxy(StreamSubscription onListen_subscription$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [onListen_subscription$],
            {},
          );
      return target$.asBroadcastStream(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
      );
    };
Function _StreamView_listen$(
  m.Scope scope$,
  StreamView target$,
) =>
    (
      m.FunctionPointer? onData, {
      Function? onError,
      m.FunctionPointer? onDone,
      bool? cancelOnError,
    }) {
      void onDataProxy(dynamic onData_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onData!,
            [onData_value$],
            {},
          );
      void onDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDone!,
            [],
            {},
          );
      return target$.listen(
        onData == null ? null : onDataProxy,
        cancelOnError: cancelOnError,
        onDone: onDone == null ? null : onDoneProxy,
        onError: onError,
      );
    };
Function StreamConsumer_as$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamConsumer<S>;
Function StreamConsumer_is$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamConsumer<S>;
Function _StreamConsumer_addStream$<S>(
  m.Scope scope$,
  StreamConsumer<S> target$,
) =>
    target$.addStream;
Function _StreamConsumer_close$<S>(
  m.Scope scope$,
  StreamConsumer<S> target$,
) =>
    target$.close;
Function StreamSink_as$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamSink<S>;
Function StreamSink_is$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamSink<S>;
Function _StreamSink_done$<S>(
  m.Scope scope$,
  StreamSink<S> target$,
) =>
    () {
      return target$.done;
    };
Function _StreamSink_close$<S>(
  m.Scope scope$,
  StreamSink<S> target$,
) =>
    target$.close;
Function StreamTransformer_as$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamTransformer<S, T>;
Function StreamTransformer_is$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamTransformer<S, T>;
Function _StreamTransformer__$(m.Scope scope$) => (m.FunctionPointer onListen) {
      StreamSubscription onListenProxy(
        Stream onListen_stream$,
        bool onListen_cancelOnError$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen,
            [
              onListen_stream$,
              onListen_cancelOnError$,
            ],
            {},
          );
      return StreamTransformer(onListenProxy);
    };
Function _StreamTransformer_fromHandlers_$(m.Scope scope$) => ({
      m.FunctionPointer? handleData,
      m.FunctionPointer? handleError,
      m.FunctionPointer? handleDone,
    }) {
      void handleDataProxy(
        dynamic handleData_data$,
        EventSink handleData_sink$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleData!,
            [
              handleData_data$,
              handleData_sink$,
            ],
            {},
          );
      void handleDoneProxy(EventSink handleDone_sink$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleDone!,
            [handleDone_sink$],
            {},
          );
      void handleErrorProxy(
        Object handleError_error$,
        StackTrace handleError_stackTrace$,
        EventSink handleError_sink$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleError!,
            [
              handleError_error$,
              handleError_stackTrace$,
              handleError_sink$,
            ],
            {},
          );
      return StreamTransformer.fromHandlers(
        handleData: handleData == null ? null : handleDataProxy,
        handleDone: handleDone == null ? null : handleDoneProxy,
        handleError: handleError == null ? null : handleErrorProxy,
      );
    };
Function _StreamTransformer_fromBind_$(m.Scope scope$) =>
    (m.FunctionPointer bind) {
      Stream bindProxy(Stream bind_$p0$) => scope$.engine.callFunctionPointer(
            scope$,
            bind,
            [bind_$p0$],
            {},
          );
      return StreamTransformer.fromBind(bindProxy);
    };
Function _StreamTransformer_castFrom$<SS, ST, TS, TT>(m.Scope scope$) =>
    StreamTransformer.castFrom<SS, ST, TS, TT>;
Function _StreamTransformer_bind$<S, T>(
  m.Scope scope$,
  StreamTransformer<S, T> target$,
) =>
    target$.bind;
Function _StreamTransformer_cast$<S, T, RS, RT>(
  m.Scope scope$,
  StreamTransformer<S, T> target$,
) =>
    target$.cast<RS, RT>;
Function StreamTransformerBase_as$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamTransformerBase<S, T>;
Function StreamTransformerBase_is$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamTransformerBase<S, T>;
Function _StreamTransformerBase_cast$<S, T, RS, RT>(
  m.Scope scope$,
  StreamTransformerBase<S, T> target$,
) =>
    target$.cast<RS, RT>;
Function StreamIterator_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamIterator<T>;
Function StreamIterator_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamIterator<T>;
Function _StreamIterator_current$<T>(
  m.Scope scope$,
  StreamIterator<T> target$,
) =>
    () {
      return target$.current;
    };
Function _StreamIterator__$(m.Scope scope$) => (Stream stream) {
      return StreamIterator(stream);
    };
Function _StreamIterator_moveNext$<T>(
  m.Scope scope$,
  StreamIterator<T> target$,
) =>
    target$.moveNext;
Function _StreamIterator_cancel$<T>(
  m.Scope scope$,
  StreamIterator<T> target$,
) =>
    target$.cancel;
Function MultiStreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MultiStreamController<T>;
Function MultiStreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MultiStreamController<T>;
Function _MultiStreamController_addSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.addSync;
Function _MultiStreamController_addErrorSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.addErrorSync;
Function _MultiStreamController_closeSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.closeSync;
Function StreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamController<T>;
Function StreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamController<T>;
Function _StreamController_onListen$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.onListen;
    };
Function _StreamController_onListen_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onListen) {
      void _onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onListen!,
            [],
            {},
          );
      target$.onListen = (_onListen == null ? null : _onListenProxy);
    };
Function _StreamController_onPause$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.onPause;
    };
Function _StreamController_onPause_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onPause) {
      void _onPauseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onPause!,
            [],
            {},
          );
      target$.onPause = (_onPause == null ? null : _onPauseProxy);
    };
Function _StreamController_onResume$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.onResume;
    };
Function _StreamController_onResume_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onResume) {
      void _onResumeProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onResume!,
            [],
            {},
          );
      target$.onResume = (_onResume == null ? null : _onResumeProxy);
    };
Function _StreamController_onCancel$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.onCancel;
    };
Function _StreamController_onCancel_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onCancel) {
      FutureOr<void> _onCancelProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            _onCancel!,
            [],
            {},
          );
      target$.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
Function _StreamController_stream$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.stream;
    };
Function _StreamController_sink$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.sink;
    };
Function _StreamController_isClosed$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.isClosed;
    };
Function _StreamController_isPaused$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.isPaused;
    };
Function _StreamController_hasListener$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.hasListener;
    };
Function _StreamController_done$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    () {
      return target$.done;
    };
Function _StreamController__$(m.Scope scope$) => ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onPause,
      m.FunctionPointer? onResume,
      m.FunctionPointer? onCancel,
      bool? sync,
    }) {
      FutureOr<void> onCancelProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onCancel!,
            [],
            {},
          );
      void onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [],
            {},
          );
      void onPauseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPause!,
            [],
            {},
          );
      void onResumeProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onResume!,
            [],
            {},
          );
      return StreamController(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
        onPause: onPause == null ? null : onPauseProxy,
        onResume: onResume == null ? null : onResumeProxy,
        sync: sync ?? false,
      );
    };
Function _StreamController_broadcast_$(m.Scope scope$) => ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
      bool? sync,
    }) {
      void onCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [],
            {},
          );
      void onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [],
            {},
          );
      return StreamController.broadcast(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
        sync: sync ?? false,
      );
    };
Function _StreamController_add$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.add;
Function _StreamController_addError$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.addError;
Function _StreamController_close$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.close;
Function _StreamController_addStream$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.addStream;
Function SynchronousStreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SynchronousStreamController<T>;
Function SynchronousStreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SynchronousStreamController<T>;
Function _SynchronousStreamController_add$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.add;
Function _SynchronousStreamController_addError$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.addError;
Function _SynchronousStreamController_close$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.close;
Function Timer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Timer;
Function Timer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Timer;
Function _Timer_tick$(
  m.Scope scope$,
  Timer target$,
) =>
    () {
      return target$.tick;
    };
Function _Timer_isActive$(
  m.Scope scope$,
  Timer target$,
) =>
    () {
      return target$.isActive;
    };
Function _Timer__$(m.Scope scope$) => (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return Timer(
        duration,
        callbackProxy,
      );
    };
Function _Timer_periodic_$(m.Scope scope$) => (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy(Timer callback_timer$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_timer$],
            {},
          );
      return Timer.periodic(
        duration,
        callbackProxy,
      );
    };
Function _Timer_run$(m.Scope scope$) => (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      Timer.run(callbackProxy);
    };
Function _Timer_cancel$(
  m.Scope scope$,
  Timer target$,
) =>
    target$.cancel;
Function ZoneSpecification_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ZoneSpecification;
Function ZoneSpecification_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ZoneSpecification;
Function _ZoneSpecification_handleUncaughtError$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.handleUncaughtError;
    };
Function _ZoneSpecification_run$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.run;
    };
Function _ZoneSpecification_runUnary$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.runUnary;
    };
Function _ZoneSpecification_runBinary$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.runBinary;
    };
Function _ZoneSpecification_registerCallback$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.registerCallback;
    };
Function _ZoneSpecification_registerUnaryCallback$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.registerUnaryCallback;
    };
Function _ZoneSpecification_registerBinaryCallback$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.registerBinaryCallback;
    };
Function _ZoneSpecification_errorCallback$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.errorCallback;
    };
Function _ZoneSpecification_scheduleMicrotask$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.scheduleMicrotask;
    };
Function _ZoneSpecification_createTimer$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.createTimer;
    };
Function _ZoneSpecification_createPeriodicTimer$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.createPeriodicTimer;
    };
Function _ZoneSpecification_print$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.print;
    };
Function _ZoneSpecification_fork$(
  m.Scope scope$,
  ZoneSpecification target$,
) =>
    () {
      return target$.fork;
    };
Function _ZoneSpecification__$(m.Scope scope$) => ({
      m.FunctionPointer? handleUncaughtError,
      m.FunctionPointer? run,
      m.FunctionPointer? runUnary,
      m.FunctionPointer? runBinary,
      m.FunctionPointer? registerCallback,
      m.FunctionPointer? registerUnaryCallback,
      m.FunctionPointer? registerBinaryCallback,
      m.FunctionPointer? errorCallback,
      m.FunctionPointer? scheduleMicrotask,
      m.FunctionPointer? createTimer,
      m.FunctionPointer? createPeriodicTimer,
      m.FunctionPointer? print,
      m.FunctionPointer? fork,
    }) {
      Timer createPeriodicTimerProxy(
        Zone createPeriodicTimer_self$,
        ZoneDelegate createPeriodicTimer_parent$,
        Zone createPeriodicTimer_zone$,
        Duration createPeriodicTimer_period$,
        void Function(Timer) createPeriodicTimer_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createPeriodicTimer!,
            [
              createPeriodicTimer_self$,
              createPeriodicTimer_parent$,
              createPeriodicTimer_zone$,
              createPeriodicTimer_period$,
              createPeriodicTimer_f$,
            ],
            {},
          );
      Timer createTimerProxy(
        Zone createTimer_self$,
        ZoneDelegate createTimer_parent$,
        Zone createTimer_zone$,
        Duration createTimer_duration$,
        void Function() createTimer_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createTimer!,
            [
              createTimer_self$,
              createTimer_parent$,
              createTimer_zone$,
              createTimer_duration$,
              createTimer_f$,
            ],
            {},
          );
      AsyncError? errorCallbackProxy(
        Zone errorCallback_self$,
        ZoneDelegate errorCallback_parent$,
        Zone errorCallback_zone$,
        Object errorCallback_error$,
        StackTrace? errorCallback_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorCallback!,
            [
              errorCallback_self$,
              errorCallback_parent$,
              errorCallback_zone$,
              errorCallback_error$,
              errorCallback_stackTrace$,
            ],
            {},
          );
      Zone forkProxy(
        Zone fork_self$,
        ZoneDelegate fork_parent$,
        Zone fork_zone$,
        ZoneSpecification? fork_specification$,
        Map? fork_zoneValues$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            fork!,
            [
              fork_self$,
              fork_parent$,
              fork_zone$,
              fork_specification$,
              fork_zoneValues$,
            ],
            {},
          );
      void handleUncaughtErrorProxy(
        Zone handleUncaughtError_self$,
        ZoneDelegate handleUncaughtError_parent$,
        Zone handleUncaughtError_zone$,
        Object handleUncaughtError_error$,
        StackTrace handleUncaughtError_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleUncaughtError!,
            [
              handleUncaughtError_self$,
              handleUncaughtError_parent$,
              handleUncaughtError_zone$,
              handleUncaughtError_error$,
              handleUncaughtError_stackTrace$,
            ],
            {},
          );
      void printProxy(
        Zone print_self$,
        ZoneDelegate print_parent$,
        Zone print_zone$,
        String print_line$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            print!,
            [
              print_self$,
              print_parent$,
              print_zone$,
              print_line$,
            ],
            {},
          );
      R Function(T1, T2) registerBinaryCallbackProxy<R, T1, T2>(
        Zone registerBinaryCallback_self$,
        ZoneDelegate registerBinaryCallback_parent$,
        Zone registerBinaryCallback_zone$,
        R Function(T1, T2) registerBinaryCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerBinaryCallback!,
            [
              registerBinaryCallback_self$,
              registerBinaryCallback_parent$,
              registerBinaryCallback_zone$,
              registerBinaryCallback_f$,
            ],
            {},
          );
      R Function() registerCallbackProxy<R>(
        Zone registerCallback_self$,
        ZoneDelegate registerCallback_parent$,
        Zone registerCallback_zone$,
        R Function() registerCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerCallback!,
            [
              registerCallback_self$,
              registerCallback_parent$,
              registerCallback_zone$,
              registerCallback_f$,
            ],
            {},
          );
      R Function(T) registerUnaryCallbackProxy<R, T>(
        Zone registerUnaryCallback_self$,
        ZoneDelegate registerUnaryCallback_parent$,
        Zone registerUnaryCallback_zone$,
        R Function(T) registerUnaryCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerUnaryCallback!,
            [
              registerUnaryCallback_self$,
              registerUnaryCallback_parent$,
              registerUnaryCallback_zone$,
              registerUnaryCallback_f$,
            ],
            {},
          );
      R runProxy<R>(
        Zone run_self$,
        ZoneDelegate run_parent$,
        Zone run_zone$,
        R Function() run_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            run!,
            [
              run_self$,
              run_parent$,
              run_zone$,
              run_f$,
            ],
            {},
          );
      R runBinaryProxy<R, T1, T2>(
        Zone runBinary_self$,
        ZoneDelegate runBinary_parent$,
        Zone runBinary_zone$,
        R Function(T1, T2) runBinary_f$,
        dynamic runBinary_arg1$,
        dynamic runBinary_arg2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runBinary!,
            [
              runBinary_self$,
              runBinary_parent$,
              runBinary_zone$,
              runBinary_f$,
              runBinary_arg1$,
              runBinary_arg2$,
            ],
            {},
          );
      R runUnaryProxy<R, T>(
        Zone runUnary_self$,
        ZoneDelegate runUnary_parent$,
        Zone runUnary_zone$,
        R Function(T) runUnary_f$,
        dynamic runUnary_arg$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runUnary!,
            [
              runUnary_self$,
              runUnary_parent$,
              runUnary_zone$,
              runUnary_f$,
              runUnary_arg$,
            ],
            {},
          );
      void scheduleMicrotaskProxy(
        Zone scheduleMicrotask_self$,
        ZoneDelegate scheduleMicrotask_parent$,
        Zone scheduleMicrotask_zone$,
        void Function() scheduleMicrotask_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            scheduleMicrotask!,
            [
              scheduleMicrotask_self$,
              scheduleMicrotask_parent$,
              scheduleMicrotask_zone$,
              scheduleMicrotask_f$,
            ],
            {},
          );
      return ZoneSpecification(
        createPeriodicTimer:
            createPeriodicTimer == null ? null : createPeriodicTimerProxy,
        createTimer: createTimer == null ? null : createTimerProxy,
        errorCallback: errorCallback == null ? null : errorCallbackProxy,
        fork: fork == null ? null : forkProxy,
        handleUncaughtError:
            handleUncaughtError == null ? null : handleUncaughtErrorProxy,
        print: print == null ? null : printProxy,
        registerBinaryCallback:
            registerBinaryCallback == null ? null : registerBinaryCallbackProxy,
        registerCallback:
            registerCallback == null ? null : registerCallbackProxy,
        registerUnaryCallback:
            registerUnaryCallback == null ? null : registerUnaryCallbackProxy,
        run: run == null ? null : runProxy,
        runBinary: runBinary == null ? null : runBinaryProxy,
        runUnary: runUnary == null ? null : runUnaryProxy,
        scheduleMicrotask:
            scheduleMicrotask == null ? null : scheduleMicrotaskProxy,
      );
    };
Function _ZoneSpecification_from_$(m.Scope scope$) => (
      ZoneSpecification other, {
      m.FunctionPointer? handleUncaughtError,
      m.FunctionPointer? run,
      m.FunctionPointer? runUnary,
      m.FunctionPointer? runBinary,
      m.FunctionPointer? registerCallback,
      m.FunctionPointer? registerUnaryCallback,
      m.FunctionPointer? registerBinaryCallback,
      m.FunctionPointer? errorCallback,
      m.FunctionPointer? scheduleMicrotask,
      m.FunctionPointer? createTimer,
      m.FunctionPointer? createPeriodicTimer,
      m.FunctionPointer? print,
      m.FunctionPointer? fork,
    }) {
      Timer createPeriodicTimerProxy(
        Zone createPeriodicTimer_self$,
        ZoneDelegate createPeriodicTimer_parent$,
        Zone createPeriodicTimer_zone$,
        Duration createPeriodicTimer_period$,
        void Function(Timer) createPeriodicTimer_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createPeriodicTimer!,
            [
              createPeriodicTimer_self$,
              createPeriodicTimer_parent$,
              createPeriodicTimer_zone$,
              createPeriodicTimer_period$,
              createPeriodicTimer_f$,
            ],
            {},
          );
      Timer createTimerProxy(
        Zone createTimer_self$,
        ZoneDelegate createTimer_parent$,
        Zone createTimer_zone$,
        Duration createTimer_duration$,
        void Function() createTimer_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createTimer!,
            [
              createTimer_self$,
              createTimer_parent$,
              createTimer_zone$,
              createTimer_duration$,
              createTimer_f$,
            ],
            {},
          );
      AsyncError? errorCallbackProxy(
        Zone errorCallback_self$,
        ZoneDelegate errorCallback_parent$,
        Zone errorCallback_zone$,
        Object errorCallback_error$,
        StackTrace? errorCallback_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorCallback!,
            [
              errorCallback_self$,
              errorCallback_parent$,
              errorCallback_zone$,
              errorCallback_error$,
              errorCallback_stackTrace$,
            ],
            {},
          );
      Zone forkProxy(
        Zone fork_self$,
        ZoneDelegate fork_parent$,
        Zone fork_zone$,
        ZoneSpecification? fork_specification$,
        Map? fork_zoneValues$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            fork!,
            [
              fork_self$,
              fork_parent$,
              fork_zone$,
              fork_specification$,
              fork_zoneValues$,
            ],
            {},
          );
      void handleUncaughtErrorProxy(
        Zone handleUncaughtError_self$,
        ZoneDelegate handleUncaughtError_parent$,
        Zone handleUncaughtError_zone$,
        Object handleUncaughtError_error$,
        StackTrace handleUncaughtError_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleUncaughtError!,
            [
              handleUncaughtError_self$,
              handleUncaughtError_parent$,
              handleUncaughtError_zone$,
              handleUncaughtError_error$,
              handleUncaughtError_stackTrace$,
            ],
            {},
          );
      void printProxy(
        Zone print_self$,
        ZoneDelegate print_parent$,
        Zone print_zone$,
        String print_line$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            print!,
            [
              print_self$,
              print_parent$,
              print_zone$,
              print_line$,
            ],
            {},
          );
      R Function(T1, T2) registerBinaryCallbackProxy<R, T1, T2>(
        Zone registerBinaryCallback_self$,
        ZoneDelegate registerBinaryCallback_parent$,
        Zone registerBinaryCallback_zone$,
        R Function(T1, T2) registerBinaryCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerBinaryCallback!,
            [
              registerBinaryCallback_self$,
              registerBinaryCallback_parent$,
              registerBinaryCallback_zone$,
              registerBinaryCallback_f$,
            ],
            {},
          );
      R Function() registerCallbackProxy<R>(
        Zone registerCallback_self$,
        ZoneDelegate registerCallback_parent$,
        Zone registerCallback_zone$,
        R Function() registerCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerCallback!,
            [
              registerCallback_self$,
              registerCallback_parent$,
              registerCallback_zone$,
              registerCallback_f$,
            ],
            {},
          );
      R Function(T) registerUnaryCallbackProxy<R, T>(
        Zone registerUnaryCallback_self$,
        ZoneDelegate registerUnaryCallback_parent$,
        Zone registerUnaryCallback_zone$,
        R Function(T) registerUnaryCallback_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerUnaryCallback!,
            [
              registerUnaryCallback_self$,
              registerUnaryCallback_parent$,
              registerUnaryCallback_zone$,
              registerUnaryCallback_f$,
            ],
            {},
          );
      R runProxy<R>(
        Zone run_self$,
        ZoneDelegate run_parent$,
        Zone run_zone$,
        R Function() run_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            run!,
            [
              run_self$,
              run_parent$,
              run_zone$,
              run_f$,
            ],
            {},
          );
      R runBinaryProxy<R, T1, T2>(
        Zone runBinary_self$,
        ZoneDelegate runBinary_parent$,
        Zone runBinary_zone$,
        R Function(T1, T2) runBinary_f$,
        dynamic runBinary_arg1$,
        dynamic runBinary_arg2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runBinary!,
            [
              runBinary_self$,
              runBinary_parent$,
              runBinary_zone$,
              runBinary_f$,
              runBinary_arg1$,
              runBinary_arg2$,
            ],
            {},
          );
      R runUnaryProxy<R, T>(
        Zone runUnary_self$,
        ZoneDelegate runUnary_parent$,
        Zone runUnary_zone$,
        R Function(T) runUnary_f$,
        dynamic runUnary_arg$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runUnary!,
            [
              runUnary_self$,
              runUnary_parent$,
              runUnary_zone$,
              runUnary_f$,
              runUnary_arg$,
            ],
            {},
          );
      void scheduleMicrotaskProxy(
        Zone scheduleMicrotask_self$,
        ZoneDelegate scheduleMicrotask_parent$,
        Zone scheduleMicrotask_zone$,
        void Function() scheduleMicrotask_f$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            scheduleMicrotask!,
            [
              scheduleMicrotask_self$,
              scheduleMicrotask_parent$,
              scheduleMicrotask_zone$,
              scheduleMicrotask_f$,
            ],
            {},
          );
      return ZoneSpecification.from(
        other,
        createPeriodicTimer:
            createPeriodicTimer == null ? null : createPeriodicTimerProxy,
        createTimer: createTimer == null ? null : createTimerProxy,
        errorCallback: errorCallback == null ? null : errorCallbackProxy,
        fork: fork == null ? null : forkProxy,
        handleUncaughtError:
            handleUncaughtError == null ? null : handleUncaughtErrorProxy,
        print: print == null ? null : printProxy,
        registerBinaryCallback:
            registerBinaryCallback == null ? null : registerBinaryCallbackProxy,
        registerCallback:
            registerCallback == null ? null : registerCallbackProxy,
        registerUnaryCallback:
            registerUnaryCallback == null ? null : registerUnaryCallbackProxy,
        run: run == null ? null : runProxy,
        runBinary: runBinary == null ? null : runBinaryProxy,
        runUnary: runUnary == null ? null : runUnaryProxy,
        scheduleMicrotask:
            scheduleMicrotask == null ? null : scheduleMicrotaskProxy,
      );
    };
Function ZoneDelegate_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ZoneDelegate;
Function ZoneDelegate_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ZoneDelegate;
Function _ZoneDelegate_handleUncaughtError$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.handleUncaughtError;
Function _ZoneDelegate_run$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.run(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_runUnary$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
      dynamic arg,
    ) {
      dynamic fProxy(dynamic f_arg$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_arg$],
            {},
          );
      return target$.runUnary(
        zone,
        fProxy,
        arg,
      );
    };
Function _ZoneDelegate_runBinary$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
      dynamic arg1,
      dynamic arg2,
    ) {
      dynamic fProxy(
        dynamic f_arg1$,
        dynamic f_arg2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            f,
            [
              f_arg1$,
              f_arg2$,
            ],
            {},
          );
      return target$.runBinary(
        zone,
        fProxy,
        arg1,
        arg2,
      );
    };
Function _ZoneDelegate_registerCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.registerCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_registerUnaryCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy(dynamic f_arg$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_arg$],
            {},
          );
      return target$.registerUnaryCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_registerBinaryCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy(
        dynamic f_arg1$,
        dynamic f_arg2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            f,
            [
              f_arg1$,
              f_arg2$,
            ],
            {},
          );
      return target$.registerBinaryCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_errorCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.errorCallback;
Function _ZoneDelegate_scheduleMicrotask$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      void fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      target$.scheduleMicrotask(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_createTimer$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      Duration duration,
      m.FunctionPointer f,
    ) {
      void fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.createTimer(
        zone,
        duration,
        fProxy,
      );
    };
Function _ZoneDelegate_createPeriodicTimer$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      Duration period,
      m.FunctionPointer f,
    ) {
      void fProxy(Timer f_timer$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_timer$],
            {},
          );
      return target$.createPeriodicTimer(
        zone,
        period,
        fProxy,
      );
    };
Function _ZoneDelegate_print$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.print;
Function _ZoneDelegate_fork$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.fork;
Function Zone_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Zone;
Function Zone_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Zone;
Function _Zone_root$(m.Scope scope$) => () => Zone.root;
Function _Zone_current$(m.Scope scope$) => () => Zone.current;
Function _Zone_parent$(
  m.Scope scope$,
  Zone target$,
) =>
    () {
      return target$.parent;
    };
Function _Zone_errorZone$(
  m.Scope scope$,
  Zone target$,
) =>
    () {
      return target$.errorZone;
    };
Function _Zone_handleUncaughtError$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.handleUncaughtError;
Function _Zone_inSameErrorZone$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.inSameErrorZone;
Function _Zone_fork$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.fork;
Function _Zone_run$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer action) {
      dynamic actionProxy() => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [],
            {},
          );
      return target$.run(actionProxy);
    };
Function _Zone_runUnary$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument,
    ) {
      dynamic actionProxy(dynamic action_argument$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_argument$],
            {},
          );
      return target$.runUnary(
        actionProxy,
        argument,
      );
    };
Function _Zone_runBinary$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument1,
      dynamic argument2,
    ) {
      dynamic actionProxy(
        dynamic action_argument1$,
        dynamic action_argument2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              action_argument1$,
              action_argument2$,
            ],
            {},
          );
      return target$.runBinary(
        actionProxy,
        argument1,
        argument2,
      );
    };
Function _Zone_runGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy() => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [],
            {},
          );
      target$.runGuarded(actionProxy);
    };
Function _Zone_runUnaryGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument,
    ) {
      void actionProxy(dynamic action_argument$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_argument$],
            {},
          );
      target$.runUnaryGuarded(
        actionProxy,
        argument,
      );
    };
Function _Zone_runBinaryGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument1,
      dynamic argument2,
    ) {
      void actionProxy(
        dynamic action_argument1$,
        dynamic action_argument2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              action_argument1$,
              action_argument2$,
            ],
            {},
          );
      target$.runBinaryGuarded(
        actionProxy,
        argument1,
        argument2,
      );
    };
Function _Zone_registerCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.registerCallback(callbackProxy);
    };
Function _Zone_registerUnaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(dynamic callback_arg$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_arg$],
            {},
          );
      return target$.registerUnaryCallback(callbackProxy);
    };
Function _Zone_registerBinaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(
        dynamic callback_arg1$,
        dynamic callback_arg2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              callback_arg1$,
              callback_arg2$,
            ],
            {},
          );
      return target$.registerBinaryCallback(callbackProxy);
    };
Function _Zone_bindCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.bindCallback(callbackProxy);
    };
Function _Zone_bindUnaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(dynamic callback_argument$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_argument$],
            {},
          );
      return target$.bindUnaryCallback(callbackProxy);
    };
Function _Zone_bindBinaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(
        dynamic callback_argument1$,
        dynamic callback_argument2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              callback_argument1$,
              callback_argument2$,
            ],
            {},
          );
      return target$.bindBinaryCallback(callbackProxy);
    };
Function _Zone_bindCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.bindCallbackGuarded(callbackProxy);
    };
Function _Zone_bindUnaryCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy(dynamic callback_argument$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_argument$],
            {},
          );
      return target$.bindUnaryCallbackGuarded(callbackProxy);
    };
Function _Zone_bindBinaryCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy(
        dynamic callback_argument1$,
        dynamic callback_argument2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              callback_argument1$,
              callback_argument2$,
            ],
            {},
          );
      return target$.bindBinaryCallbackGuarded(callbackProxy);
    };
Function _Zone_errorCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.errorCallback;
Function _Zone_scheduleMicrotask$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      target$.scheduleMicrotask(callbackProxy);
    };
Function _Zone_createTimer$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.createTimer(
        duration,
        callbackProxy,
      );
    };
Function _Zone_createPeriodicTimer$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      Duration period,
      m.FunctionPointer callback,
    ) {
      void callbackProxy(Timer callback_timer$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [callback_timer$],
            {},
          );
      return target$.createPeriodicTimer(
        period,
        callbackProxy,
      );
    };
Function _Zone_print$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.print;
Function _Zone_$index$$(
  m.Scope scope$,
  Zone target$,
) =>
    (Object? index) => target$[index];
Function _runZoned$(m.Scope scope$) => (
      m.FunctionPointer body, {
      Map? zoneValues,
      ZoneSpecification? zoneSpecification,
      Function? onError,
    }) {
      dynamic bodyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            body,
            [],
            {},
          );
      return runZoned(
        bodyProxy,
        onError: onError,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues == null ? null : Map.from(zoneValues),
      );
    };
Function _runZonedGuarded$(m.Scope scope$) => (
      m.FunctionPointer body,
      m.FunctionPointer onError, {
      Map? zoneValues,
      ZoneSpecification? zoneSpecification,
    }) {
      dynamic bodyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            body,
            [],
            {},
          );
      void onErrorProxy(
        Object onError_error$,
        StackTrace onError_stack$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onError,
            [
              onError_error$,
              onError_stack$,
            ],
            {},
          );
      return runZonedGuarded(
        bodyProxy,
        onErrorProxy,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues == null ? null : Map.from(zoneValues),
      );
    };
