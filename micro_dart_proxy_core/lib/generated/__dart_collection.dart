// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:collection';
import 'dart:math' show Random;

const libraryMirror = m.LibraryMirror(
  'dart:collection',
  {
    'UnmodifiableListView.': _UnmodifiableListView__$,
    'HashMap.': _HashMap__$,
    'HashMap.identity': _HashMap_identity_$,
    'HashMap.from': _HashMap_from_$,
    'HashMap.of': _HashMap_of_$,
    'HashMap.fromIterable': _HashMap_fromIterable_$,
    'HashMap.fromIterables': _HashMap_fromIterables_$,
    'HashMap.fromEntries': _HashMap_fromEntries_$,
    'HashSet.': _HashSet__$,
    'HashSet.identity': _HashSet_identity_$,
    'HashSet.from': _HashSet_from_$,
    'HashSet.of': _HashSet_of_$,
    'LinkedHashMap.': _LinkedHashMap__$,
    'LinkedHashMap.identity': _LinkedHashMap_identity_$,
    'LinkedHashMap.from': _LinkedHashMap_from_$,
    'LinkedHashMap.of': _LinkedHashMap_of_$,
    'LinkedHashMap.fromIterable': _LinkedHashMap_fromIterable_$,
    'LinkedHashMap.fromIterables': _LinkedHashMap_fromIterables_$,
    'LinkedHashMap.fromEntries': _LinkedHashMap_fromEntries_$,
    'LinkedHashSet.': _LinkedHashSet__$,
    'LinkedHashSet.identity': _LinkedHashSet_identity_$,
    'LinkedHashSet.from': _LinkedHashSet_from_$,
    'LinkedHashSet.of': _LinkedHashSet_of_$,
    'LinkedList.': _LinkedList__$,
    'ListBase.listToString': _ListBase_listToString$,
    'MapBase.mapToString': _MapBase_mapToString$,
    'MapView.': _MapView__$,
    'UnmodifiableMapView.': _UnmodifiableMapView__$,
    'Queue.': _Queue__$,
    'Queue.from': _Queue_from_$,
    'Queue.of': _Queue_of_$,
    'Queue.castFrom': _Queue_castFrom$,
    'DoubleLinkedQueue.': _DoubleLinkedQueue__$,
    'DoubleLinkedQueue.from': _DoubleLinkedQueue_from_$,
    'DoubleLinkedQueue.of': _DoubleLinkedQueue_of_$,
    'ListQueue.': _ListQueue__$,
    'ListQueue.from': _ListQueue_from_$,
    'ListQueue.of': _ListQueue_of_$,
    'SetBase.setToString': _SetBase_setToString$,
    'UnmodifiableSetView.': _UnmodifiableSetView__$,
    'SplayTreeMap.': _SplayTreeMap__$,
    'SplayTreeMap.from': _SplayTreeMap_from_$,
    'SplayTreeMap.of': _SplayTreeMap_of_$,
    'SplayTreeMap.fromIterable': _SplayTreeMap_fromIterable_$,
    'SplayTreeMap.fromIterables': _SplayTreeMap_fromIterables_$,
    'SplayTreeSet.': _SplayTreeSet__$,
    'SplayTreeSet.from': _SplayTreeSet_from_$,
    'SplayTreeSet.of': _SplayTreeSet_of_$,
  },
  {},
  {
    'UnmodifiableListView': m.ClassMirror(
      'UnmodifiableListView',
      {
        '#as': UnmodifiableListView_as$,
        '#is': UnmodifiableListView_is$,
        'length': _UnmodifiableListView_length$,
        'cast': _UnmodifiableListView_cast$,
        '[]': _UnmodifiableListView_$index$$,
      },
      {},
    ),
    'HashMap': m.ClassMirror(
      'HashMap',
      {
        '#as': HashMap_as$,
        '#is': HashMap_is$,
      },
      {},
    ),
    'HashSet': m.ClassMirror(
      'HashSet',
      {
        '#as': HashSet_as$,
        '#is': HashSet_is$,
        'iterator': _HashSet_iterator$,
      },
      {},
    ),
    'LinkedHashMap': m.ClassMirror(
      'LinkedHashMap',
      {
        '#as': LinkedHashMap_as$,
        '#is': LinkedHashMap_is$,
      },
      {},
    ),
    'LinkedHashSet': m.ClassMirror(
      'LinkedHashSet',
      {
        '#as': LinkedHashSet_as$,
        '#is': LinkedHashSet_is$,
        'iterator': _LinkedHashSet_iterator$,
        'forEach': _LinkedHashSet_forEach$,
      },
      {},
    ),
    'LinkedList': m.ClassMirror(
      'LinkedList',
      {
        '#as': LinkedList_as$,
        '#is': LinkedList_is$,
        'iterator': _LinkedList_iterator$,
        'length': _LinkedList_length$,
        'first': _LinkedList_first$,
        'last': _LinkedList_last$,
        'single': _LinkedList_single$,
        'isEmpty': _LinkedList_isEmpty$,
        'addFirst': _LinkedList_addFirst$,
        'add': _LinkedList_add$,
        'addAll': _LinkedList_addAll$,
        'remove': _LinkedList_remove$,
        'contains': _LinkedList_contains$,
        'clear': _LinkedList_clear$,
        'forEach': _LinkedList_forEach$,
      },
      {},
    ),
    'LinkedListEntry': m.ClassMirror(
      'LinkedListEntry',
      {
        '#as': LinkedListEntry_as$,
        '#is': LinkedListEntry_is$,
        'list': _LinkedListEntry_list$,
        'next': _LinkedListEntry_next$,
        'previous': _LinkedListEntry_previous$,
        'unlink': _LinkedListEntry_unlink$,
        'insertAfter': _LinkedListEntry_insertAfter$,
        'insertBefore': _LinkedListEntry_insertBefore$,
      },
      {},
    ),
    'ListBase': m.ClassMirror(
      'ListBase',
      {
        '#as': ListBase_as$,
        '#is': ListBase_is$,
        'iterator': _ListBase_iterator$,
        'isEmpty': _ListBase_isEmpty$,
        'isNotEmpty': _ListBase_isNotEmpty$,
        'first': _ListBase_first$,
        'last': _ListBase_last$,
        'single': _ListBase_single$,
        'reversed': _ListBase_reversed$,
        'elementAt': _ListBase_elementAt$,
        'followedBy': _ListBase_followedBy$,
        'forEach': _ListBase_forEach$,
        'contains': _ListBase_contains$,
        'every': _ListBase_every$,
        'any': _ListBase_any$,
        'firstWhere': _ListBase_firstWhere$,
        'lastWhere': _ListBase_lastWhere$,
        'singleWhere': _ListBase_singleWhere$,
        'join': _ListBase_join$,
        'where': _ListBase_where$,
        'whereType': _ListBase_whereType$,
        'map': _ListBase_map$,
        'expand': _ListBase_expand$,
        'reduce': _ListBase_reduce$,
        'fold': _ListBase_fold$,
        'skip': _ListBase_skip$,
        'skipWhile': _ListBase_skipWhile$,
        'take': _ListBase_take$,
        'takeWhile': _ListBase_takeWhile$,
        'toList': _ListBase_toList$,
        'toSet': _ListBase_toSet$,
        'add': _ListBase_add$,
        'addAll': _ListBase_addAll$,
        'remove': _ListBase_remove$,
        'removeWhere': _ListBase_removeWhere$,
        'retainWhere': _ListBase_retainWhere$,
        'clear': _ListBase_clear$,
        'cast': _ListBase_cast$,
        'removeLast': _ListBase_removeLast$,
        'sort': _ListBase_sort$,
        'shuffle': _ListBase_shuffle$,
        'asMap': _ListBase_asMap$,
        '+': _ListBase_plus$$,
        'sublist': _ListBase_sublist$,
        'getRange': _ListBase_getRange$,
        'removeRange': _ListBase_removeRange$,
        'fillRange': _ListBase_fillRange$,
        'setRange': _ListBase_setRange$,
        'replaceRange': _ListBase_replaceRange$,
        'indexOf': _ListBase_indexOf$,
        'indexWhere': _ListBase_indexWhere$,
        'lastIndexOf': _ListBase_lastIndexOf$,
        'lastIndexWhere': _ListBase_lastIndexWhere$,
        'insert': _ListBase_insert$,
        'removeAt': _ListBase_removeAt$,
        'insertAll': _ListBase_insertAll$,
        'setAll': _ListBase_setAll$,
        'toString': _ListBase_toString$,
      },
      {
        'first': _ListBase_first_set$,
        'last': _ListBase_last_set$,
      },
    ),
    'MapBase': m.ClassMirror(
      'MapBase',
      {
        '#as': MapBase_as$,
        '#is': MapBase_is$,
        'keys': _MapBase_keys$,
        'entries': _MapBase_entries$,
        'length': _MapBase_length$,
        'isEmpty': _MapBase_isEmpty$,
        'isNotEmpty': _MapBase_isNotEmpty$,
        'values': _MapBase_values$,
        '[]': _MapBase_$index$$,
        '[]=': _MapBase_$index_set$$,
        'remove': _MapBase_remove$,
        'clear': _MapBase_clear$,
        'cast': _MapBase_cast$,
        'forEach': _MapBase_forEach$,
        'addAll': _MapBase_addAll$,
        'containsValue': _MapBase_containsValue$,
        'putIfAbsent': _MapBase_putIfAbsent$,
        'update': _MapBase_update$,
        'updateAll': _MapBase_updateAll$,
        'map': _MapBase_map$,
        'addEntries': _MapBase_addEntries$,
        'removeWhere': _MapBase_removeWhere$,
        'containsKey': _MapBase_containsKey$,
        'toString': _MapBase_toString$,
      },
      {},
    ),
    'UnmodifiableMapBase': m.ClassMirror(
      'UnmodifiableMapBase',
      {
        '#as': UnmodifiableMapBase_as$,
        '#is': UnmodifiableMapBase_is$,
      },
      {},
    ),
    'MapView': m.ClassMirror(
      'MapView',
      {
        '#as': MapView_as$,
        '#is': MapView_is$,
        'isEmpty': _MapView_isEmpty$,
        'isNotEmpty': _MapView_isNotEmpty$,
        'length': _MapView_length$,
        'keys': _MapView_keys$,
        'values': _MapView_values$,
        'entries': _MapView_entries$,
        'cast': _MapView_cast$,
        '[]': _MapView_$index$$,
        '[]=': _MapView_$index_set$$,
        'addAll': _MapView_addAll$,
        'clear': _MapView_clear$,
        'putIfAbsent': _MapView_putIfAbsent$,
        'containsKey': _MapView_containsKey$,
        'containsValue': _MapView_containsValue$,
        'forEach': _MapView_forEach$,
        'remove': _MapView_remove$,
        'toString': _MapView_toString$,
        'addEntries': _MapView_addEntries$,
        'map': _MapView_map$,
        'update': _MapView_update$,
        'updateAll': _MapView_updateAll$,
        'removeWhere': _MapView_removeWhere$,
      },
      {},
    ),
    'UnmodifiableMapView': m.ClassMirror(
      'UnmodifiableMapView',
      {
        '#as': UnmodifiableMapView_as$,
        '#is': UnmodifiableMapView_is$,
        'cast': _UnmodifiableMapView_cast$,
      },
      {},
    ),
    'Queue': m.ClassMirror(
      'Queue',
      {
        '#as': Queue_as$,
        '#is': Queue_is$,
        'cast': _Queue_cast$,
        'removeFirst': _Queue_removeFirst$,
        'removeLast': _Queue_removeLast$,
        'addFirst': _Queue_addFirst$,
        'addLast': _Queue_addLast$,
        'add': _Queue_add$,
        'remove': _Queue_remove$,
        'addAll': _Queue_addAll$,
        'removeWhere': _Queue_removeWhere$,
        'retainWhere': _Queue_retainWhere$,
        'clear': _Queue_clear$,
      },
      {},
    ),
    'DoubleLinkedQueue': m.ClassMirror(
      'DoubleLinkedQueue',
      {
        '#as': DoubleLinkedQueue_as$,
        '#is': DoubleLinkedQueue_is$,
        'length': _DoubleLinkedQueue_length$,
        'first': _DoubleLinkedQueue_first$,
        'last': _DoubleLinkedQueue_last$,
        'single': _DoubleLinkedQueue_single$,
        'isEmpty': _DoubleLinkedQueue_isEmpty$,
        'iterator': _DoubleLinkedQueue_iterator$,
        'cast': _DoubleLinkedQueue_cast$,
        'addLast': _DoubleLinkedQueue_addLast$,
        'addFirst': _DoubleLinkedQueue_addFirst$,
        'add': _DoubleLinkedQueue_add$,
        'addAll': _DoubleLinkedQueue_addAll$,
        'removeLast': _DoubleLinkedQueue_removeLast$,
        'removeFirst': _DoubleLinkedQueue_removeFirst$,
        'remove': _DoubleLinkedQueue_remove$,
        'removeWhere': _DoubleLinkedQueue_removeWhere$,
        'retainWhere': _DoubleLinkedQueue_retainWhere$,
        'firstEntry': _DoubleLinkedQueue_firstEntry$,
        'lastEntry': _DoubleLinkedQueue_lastEntry$,
        'clear': _DoubleLinkedQueue_clear$,
        'forEachEntry': _DoubleLinkedQueue_forEachEntry$,
        'toString': _DoubleLinkedQueue_toString$,
      },
      {},
    ),
    'ListQueue': m.ClassMirror(
      'ListQueue',
      {
        '#as': ListQueue_as$,
        '#is': ListQueue_is$,
        'iterator': _ListQueue_iterator$,
        'isEmpty': _ListQueue_isEmpty$,
        'length': _ListQueue_length$,
        'first': _ListQueue_first$,
        'last': _ListQueue_last$,
        'single': _ListQueue_single$,
        'cast': _ListQueue_cast$,
        'forEach': _ListQueue_forEach$,
        'elementAt': _ListQueue_elementAt$,
        'toList': _ListQueue_toList$,
        'add': _ListQueue_add$,
        'addAll': _ListQueue_addAll$,
        'remove': _ListQueue_remove$,
        'removeWhere': _ListQueue_removeWhere$,
        'retainWhere': _ListQueue_retainWhere$,
        'clear': _ListQueue_clear$,
        'toString': _ListQueue_toString$,
        'addLast': _ListQueue_addLast$,
        'addFirst': _ListQueue_addFirst$,
        'removeFirst': _ListQueue_removeFirst$,
        'removeLast': _ListQueue_removeLast$,
      },
      {},
    ),
    'SetBase': m.ClassMirror(
      'SetBase',
      {
        '#as': SetBase_as$,
        '#is': SetBase_is$,
        'iterator': _SetBase_iterator$,
        'length': _SetBase_length$,
        'isEmpty': _SetBase_isEmpty$,
        'isNotEmpty': _SetBase_isNotEmpty$,
        'single': _SetBase_single$,
        'first': _SetBase_first$,
        'last': _SetBase_last$,
        'add': _SetBase_add$,
        'contains': _SetBase_contains$,
        'lookup': _SetBase_lookup$,
        'remove': _SetBase_remove$,
        'toSet': _SetBase_toSet$,
        'cast': _SetBase_cast$,
        'followedBy': _SetBase_followedBy$,
        'whereType': _SetBase_whereType$,
        'clear': _SetBase_clear$,
        'addAll': _SetBase_addAll$,
        'removeAll': _SetBase_removeAll$,
        'retainAll': _SetBase_retainAll$,
        'removeWhere': _SetBase_removeWhere$,
        'retainWhere': _SetBase_retainWhere$,
        'containsAll': _SetBase_containsAll$,
        'union': _SetBase_union$,
        'intersection': _SetBase_intersection$,
        'difference': _SetBase_difference$,
        'toList': _SetBase_toList$,
        'map': _SetBase_map$,
        'toString': _SetBase_toString$,
        'where': _SetBase_where$,
        'expand': _SetBase_expand$,
        'forEach': _SetBase_forEach$,
        'reduce': _SetBase_reduce$,
        'fold': _SetBase_fold$,
        'every': _SetBase_every$,
        'join': _SetBase_join$,
        'any': _SetBase_any$,
        'take': _SetBase_take$,
        'takeWhile': _SetBase_takeWhile$,
        'skip': _SetBase_skip$,
        'skipWhile': _SetBase_skipWhile$,
        'firstWhere': _SetBase_firstWhere$,
        'lastWhere': _SetBase_lastWhere$,
        'singleWhere': _SetBase_singleWhere$,
        'elementAt': _SetBase_elementAt$,
      },
      {},
    ),
    'UnmodifiableSetView': m.ClassMirror(
      'UnmodifiableSetView',
      {
        '#as': UnmodifiableSetView_as$,
        '#is': UnmodifiableSetView_is$,
        'length': _UnmodifiableSetView_length$,
        'iterator': _UnmodifiableSetView_iterator$,
        'contains': _UnmodifiableSetView_contains$,
        'lookup': _UnmodifiableSetView_lookup$,
        'toSet': _UnmodifiableSetView_toSet$,
      },
      {},
    ),
    'SplayTreeMap': m.ClassMirror(
      'SplayTreeMap',
      {
        '#as': SplayTreeMap_as$,
        '#is': SplayTreeMap_is$,
        'isEmpty': _SplayTreeMap_isEmpty$,
        'isNotEmpty': _SplayTreeMap_isNotEmpty$,
        'length': _SplayTreeMap_length$,
        'keys': _SplayTreeMap_keys$,
        'values': _SplayTreeMap_values$,
        'entries': _SplayTreeMap_entries$,
        '[]': _SplayTreeMap_$index$$,
        'remove': _SplayTreeMap_remove$,
        '[]=': _SplayTreeMap_$index_set$$,
        'putIfAbsent': _SplayTreeMap_putIfAbsent$,
        'update': _SplayTreeMap_update$,
        'updateAll': _SplayTreeMap_updateAll$,
        'addAll': _SplayTreeMap_addAll$,
        'forEach': _SplayTreeMap_forEach$,
        'clear': _SplayTreeMap_clear$,
        'containsKey': _SplayTreeMap_containsKey$,
        'containsValue': _SplayTreeMap_containsValue$,
        'firstKey': _SplayTreeMap_firstKey$,
        'lastKey': _SplayTreeMap_lastKey$,
        'lastKeyBefore': _SplayTreeMap_lastKeyBefore$,
        'firstKeyAfter': _SplayTreeMap_firstKeyAfter$,
      },
      {},
    ),
    'SplayTreeSet': m.ClassMirror(
      'SplayTreeSet',
      {
        '#as': SplayTreeSet_as$,
        '#is': SplayTreeSet_is$,
        'iterator': _SplayTreeSet_iterator$,
        'length': _SplayTreeSet_length$,
        'isEmpty': _SplayTreeSet_isEmpty$,
        'isNotEmpty': _SplayTreeSet_isNotEmpty$,
        'first': _SplayTreeSet_first$,
        'last': _SplayTreeSet_last$,
        'single': _SplayTreeSet_single$,
        'cast': _SplayTreeSet_cast$,
        'contains': _SplayTreeSet_contains$,
        'add': _SplayTreeSet_add$,
        'remove': _SplayTreeSet_remove$,
        'addAll': _SplayTreeSet_addAll$,
        'removeAll': _SplayTreeSet_removeAll$,
        'retainAll': _SplayTreeSet_retainAll$,
        'lookup': _SplayTreeSet_lookup$,
        'intersection': _SplayTreeSet_intersection$,
        'difference': _SplayTreeSet_difference$,
        'union': _SplayTreeSet_union$,
        'clear': _SplayTreeSet_clear$,
        'toSet': _SplayTreeSet_toSet$,
        'toString': _SplayTreeSet_toString$,
      },
      {},
    ),
  },
);
Function UnmodifiableListView_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnmodifiableListView<E>;
Function UnmodifiableListView_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnmodifiableListView<E>;
Function _UnmodifiableListView_length$<E>(
  m.Scope scope$,
  UnmodifiableListView<E> target$,
) =>
    () {
      return target$.length;
    };
Function _UnmodifiableListView__$(m.Scope scope$) => (Iterable source) {
      return UnmodifiableListView(Iterable.castFrom(source));
    };
Function _UnmodifiableListView_cast$<E, R>(
  m.Scope scope$,
  UnmodifiableListView<E> target$,
) =>
    target$.cast<R>;
Function _UnmodifiableListView_$index$$<E>(
  m.Scope scope$,
  UnmodifiableListView<E> target$,
) =>
    (int index) => target$[index];
Function HashMap_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as HashMap<K, V>;
Function HashMap_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is HashMap<K, V>;
Function _HashMap__$(m.Scope scope$) => ({
      m.FunctionPointer? equals,
      m.FunctionPointer? hashCode,
      m.FunctionPointer? isValidKey,
    }) {
      bool equalsProxy(
        dynamic equals_$p0$,
        dynamic equals_$p1$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              equals_$p0$,
              equals_$p1$,
            ],
            {},
          );
      int hashCodeProxy(dynamic hashCode_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            hashCode!,
            [hashCode_$p0$],
            {},
          );
      bool isValidKeyProxy(dynamic isValidKey_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_$p0$],
            {},
          );
      return HashMap(
        equals: equals == null ? null : equalsProxy,
        hashCode: hashCode == null ? null : hashCodeProxy,
        isValidKey: isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _HashMap_identity_$(m.Scope scope$) => HashMap.identity;
Function _HashMap_from_$(m.Scope scope$) => HashMap.from;
Function _HashMap_of_$(m.Scope scope$) => HashMap.of;
Function _HashMap_fromIterable_$(m.Scope scope$) => (
      Iterable iterable, {
      m.FunctionPointer? key,
      m.FunctionPointer? value,
    }) {
      dynamic keyProxy(dynamic key_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            key!,
            [key_element$],
            {},
          );
      dynamic valueProxy(dynamic value_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_element$],
            {},
          );
      return HashMap.fromIterable(
        Iterable.castFrom(iterable),
        key: key == null ? null : keyProxy,
        value: value == null ? null : valueProxy,
      );
    };
Function _HashMap_fromIterables_$(m.Scope scope$) => HashMap.fromIterables;
Function _HashMap_fromEntries_$(m.Scope scope$) => HashMap.fromEntries;
Function HashSet_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as HashSet<E>;
Function HashSet_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is HashSet<E>;
Function _HashSet_iterator$<E>(
  m.Scope scope$,
  HashSet<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _HashSet__$(m.Scope scope$) => ({
      m.FunctionPointer? equals,
      m.FunctionPointer? hashCode,
      m.FunctionPointer? isValidKey,
    }) {
      bool equalsProxy(
        dynamic equals_$p0$,
        dynamic equals_$p1$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              equals_$p0$,
              equals_$p1$,
            ],
            {},
          );
      int hashCodeProxy(dynamic hashCode_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            hashCode!,
            [hashCode_$p0$],
            {},
          );
      bool isValidKeyProxy(dynamic isValidKey_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_$p0$],
            {},
          );
      return HashSet(
        equals: equals == null ? null : equalsProxy,
        hashCode: hashCode == null ? null : hashCodeProxy,
        isValidKey: isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _HashSet_identity_$(m.Scope scope$) => HashSet.identity;
Function _HashSet_from_$(m.Scope scope$) => HashSet.from;
Function _HashSet_of_$(m.Scope scope$) => HashSet.of;
Function LinkedHashMap_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinkedHashMap<K, V>;
Function LinkedHashMap_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinkedHashMap<K, V>;
Function _LinkedHashMap__$(m.Scope scope$) => ({
      m.FunctionPointer? equals,
      m.FunctionPointer? hashCode,
      m.FunctionPointer? isValidKey,
    }) {
      bool equalsProxy(
        dynamic equals_$p0$,
        dynamic equals_$p1$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              equals_$p0$,
              equals_$p1$,
            ],
            {},
          );
      int hashCodeProxy(dynamic hashCode_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            hashCode!,
            [hashCode_$p0$],
            {},
          );
      bool isValidKeyProxy(dynamic isValidKey_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_$p0$],
            {},
          );
      return LinkedHashMap(
        equals: equals == null ? null : equalsProxy,
        hashCode: hashCode == null ? null : hashCodeProxy,
        isValidKey: isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _LinkedHashMap_identity_$(m.Scope scope$) => LinkedHashMap.identity;
Function _LinkedHashMap_from_$(m.Scope scope$) => LinkedHashMap.from;
Function _LinkedHashMap_of_$(m.Scope scope$) => LinkedHashMap.of;
Function _LinkedHashMap_fromIterable_$(m.Scope scope$) => (
      Iterable iterable, {
      m.FunctionPointer? key,
      m.FunctionPointer? value,
    }) {
      dynamic keyProxy(dynamic key_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            key!,
            [key_element$],
            {},
          );
      dynamic valueProxy(dynamic value_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_element$],
            {},
          );
      return LinkedHashMap.fromIterable(
        Iterable.castFrom(iterable),
        key: key == null ? null : keyProxy,
        value: value == null ? null : valueProxy,
      );
    };
Function _LinkedHashMap_fromIterables_$(m.Scope scope$) =>
    LinkedHashMap.fromIterables;
Function _LinkedHashMap_fromEntries_$(m.Scope scope$) =>
    LinkedHashMap.fromEntries;
Function LinkedHashSet_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinkedHashSet<E>;
Function LinkedHashSet_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinkedHashSet<E>;
Function _LinkedHashSet_iterator$<E>(
  m.Scope scope$,
  LinkedHashSet<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _LinkedHashSet__$(m.Scope scope$) => ({
      m.FunctionPointer? equals,
      m.FunctionPointer? hashCode,
      m.FunctionPointer? isValidKey,
    }) {
      bool equalsProxy(
        dynamic equals_$p0$,
        dynamic equals_$p1$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              equals_$p0$,
              equals_$p1$,
            ],
            {},
          );
      int hashCodeProxy(dynamic hashCode_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            hashCode!,
            [hashCode_$p0$],
            {},
          );
      bool isValidKeyProxy(dynamic isValidKey_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_$p0$],
            {},
          );
      return LinkedHashSet(
        equals: equals == null ? null : equalsProxy,
        hashCode: hashCode == null ? null : hashCodeProxy,
        isValidKey: isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _LinkedHashSet_identity_$(m.Scope scope$) => LinkedHashSet.identity;
Function _LinkedHashSet_from_$(m.Scope scope$) => LinkedHashSet.from;
Function _LinkedHashSet_of_$(m.Scope scope$) => LinkedHashSet.of;
Function _LinkedHashSet_forEach$(
  m.Scope scope$,
  LinkedHashSet target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(dynamic action_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_element$],
            {},
          );
      target$.forEach(actionProxy);
    };
Function LinkedList_as$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinkedList<E>;
Function LinkedList_is$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinkedList<E>;
Function _LinkedList_iterator$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _LinkedList_length$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.length;
    };
Function _LinkedList_first$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.first;
    };
Function _LinkedList_last$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.last;
    };
Function _LinkedList_single$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.single;
    };
Function _LinkedList_isEmpty$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _LinkedList__$(m.Scope scope$) => <E extends LinkedListEntry<E>>() {
      return LinkedList<E>();
    };
Function _LinkedList_addFirst$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.addFirst;
Function _LinkedList_add$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.add;
Function _LinkedList_addAll$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.addAll;
Function _LinkedList_remove$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.remove;
Function _LinkedList_contains$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.contains;
Function _LinkedList_clear$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedList<E> target$,
) =>
    target$.clear;
Function _LinkedList_forEach$(
  m.Scope scope$,
  LinkedList target$,
) =>
    <E extends LinkedListEntry<E>>(m.FunctionPointer action) {
      void actionProxy(dynamic action_entry$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_entry$],
            {},
          );
      target$.forEach(actionProxy);
    };
Function LinkedListEntry_as$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinkedListEntry<E>;
Function LinkedListEntry_is$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinkedListEntry<E>;
Function _LinkedListEntry_list$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    () {
      return target$.list;
    };
Function _LinkedListEntry_next$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    () {
      return target$.next;
    };
Function _LinkedListEntry_previous$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    () {
      return target$.previous;
    };
Function _LinkedListEntry_unlink$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    target$.unlink;
Function _LinkedListEntry_insertAfter$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    target$.insertAfter;
Function _LinkedListEntry_insertBefore$<E extends LinkedListEntry<E>>(
  m.Scope scope$,
  LinkedListEntry<E> target$,
) =>
    target$.insertBefore;
Function ListBase_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ListBase<E>;
Function ListBase_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ListBase<E>;
Function _ListBase_iterator$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _ListBase_isEmpty$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _ListBase_isNotEmpty$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _ListBase_first$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.first;
    };
void _ListBase_first_set$<E>(
  m.Scope scope$,
  ListBase target$,
) =>
    (dynamic other$) {
      target$.first = other$;
    };
Function _ListBase_last$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.last;
    };
void _ListBase_last_set$<E>(
  m.Scope scope$,
  ListBase target$,
) =>
    (dynamic other$) {
      target$.last = other$;
    };
Function _ListBase_single$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.single;
    };
Function _ListBase_reversed$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    () {
      return target$.reversed;
    };
Function _ListBase_elementAt$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.elementAt;
Function _ListBase_followedBy$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.followedBy;
Function _ListBase_forEach$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(dynamic action_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_element$],
            {},
          );
      target$.forEach(actionProxy);
    };
Function _ListBase_contains$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.contains;
Function _ListBase_every$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.every(testProxy);
    };
Function _ListBase_any$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.any(testProxy);
    };
Function _ListBase_firstWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.firstWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _ListBase_lastWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.lastWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _ListBase_singleWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _ListBase_join$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.join;
Function _ListBase_where$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.where(testProxy);
    };
Function _ListBase_whereType$<E, T>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.whereType<T>;
Function _ListBase_map$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer f) {
      dynamic fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.map(fProxy);
    };
Function _ListBase_expand$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer f) {
      Iterable fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.expand(fProxy);
    };
Function _ListBase_reduce$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer combine) {
      dynamic combineProxy(
        dynamic combine_previousValue$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previousValue$,
              combine_element$,
            ],
            {},
          );
      return target$.reduce(combineProxy);
    };
Function _ListBase_fold$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      dynamic initialValue,
      m.FunctionPointer combine,
    ) {
      dynamic combineProxy(
        dynamic combine_previousValue$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previousValue$,
              combine_element$,
            ],
            {},
          );
      return target$.fold(
        initialValue,
        combineProxy,
      );
    };
Function _ListBase_skip$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.skip;
Function _ListBase_skipWhile$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.skipWhile(testProxy);
    };
Function _ListBase_take$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.take;
Function _ListBase_takeWhile$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.takeWhile(testProxy);
    };
Function _ListBase_toList$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.toList;
Function _ListBase_toSet$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.toSet;
Function _ListBase_add$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.add;
Function _ListBase_addAll$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.addAll;
Function _ListBase_remove$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.remove;
Function _ListBase_removeWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _ListBase_retainWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _ListBase_clear$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.clear;
Function _ListBase_cast$<E, R>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.cast<R>;
Function _ListBase_removeLast$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.removeLast;
Function _ListBase_sort$(
  m.Scope scope$,
  ListBase target$,
) =>
    ([m.FunctionPointer? compare]) {
      if (compare == null) {
        target$.sort();
      }
      int compareProxy(
        dynamic compare_a$,
        dynamic compare_b$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_a$,
              compare_b$,
            ],
            {},
          );
      target$.sort(compare == null ? null : compareProxy);
      return;
    };
Function _ListBase_shuffle$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.shuffle;
Function _ListBase_asMap$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.asMap;
Function _ListBase_plus$$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    (List<E> other$) => target$ + other$;
Function _ListBase_sublist$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.sublist;
Function _ListBase_getRange$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.getRange;
Function _ListBase_removeRange$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.removeRange;
Function _ListBase_fillRange$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.fillRange;
Function _ListBase_setRange$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.setRange;
Function _ListBase_replaceRange$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.replaceRange;
Function _ListBase_indexOf$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.indexOf;
Function _ListBase_indexWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      m.FunctionPointer test, [
      int? start,
    ]) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      if (start == null) {
        return target$.indexWhere(testProxy);
      }
      return target$.indexWhere(
        testProxy,
        start!,
      );
    };
Function _ListBase_lastIndexOf$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.lastIndexOf;
Function _ListBase_lastIndexWhere$(
  m.Scope scope$,
  ListBase target$,
) =>
    (
      m.FunctionPointer test, [
      int? start,
    ]) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      if (start == null) {
        return target$.lastIndexWhere(testProxy);
      }
      return target$.lastIndexWhere(
        testProxy,
        start!,
      );
    };
Function _ListBase_insert$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.insert;
Function _ListBase_removeAt$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.removeAt;
Function _ListBase_insertAll$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.insertAll;
Function _ListBase_setAll$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.setAll;
Function _ListBase_toString$<E>(
  m.Scope scope$,
  ListBase<E> target$,
) =>
    target$.toString;
Function _ListBase_listToString$(m.Scope scope$) => ListBase.listToString;
Function MapBase_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MapBase<K, V>;
Function MapBase_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MapBase<K, V>;
Function _MapBase_keys$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.keys;
    };
Function _MapBase_entries$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.entries;
    };
Function _MapBase_length$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.length;
    };
Function _MapBase_isEmpty$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _MapBase_isNotEmpty$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _MapBase_values$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    () {
      return target$.values;
    };
Function _MapBase_$index$$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    (Object? index) => target$[index];
Function _MapBase_$index_set$$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    (
      K index,
      V other,
    ) =>
        target$[index] = other;
Function _MapBase_remove$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.remove;
Function _MapBase_clear$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.clear;
Function _MapBase_cast$<K, V, RK, RV>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.cast<RK, RV>;
Function _MapBase_forEach$(
  m.Scope scope$,
  MapBase target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(
        dynamic action_key$,
        dynamic action_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              action_key$,
              action_value$,
            ],
            {},
          );
      target$.forEach(actionProxy);
    };
Function _MapBase_addAll$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.addAll;
Function _MapBase_containsValue$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.containsValue;
Function _MapBase_putIfAbsent$(
  m.Scope scope$,
  MapBase target$,
) =>
    (
      dynamic key,
      m.FunctionPointer ifAbsent,
    ) {
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent,
            [],
            {},
          );
      return target$.putIfAbsent(
        key,
        ifAbsentProxy,
      );
    };
Function _MapBase_update$(
  m.Scope scope$,
  MapBase target$,
) =>
    (
      dynamic key,
      m.FunctionPointer update, {
      m.FunctionPointer? ifAbsent,
    }) {
      dynamic updateProxy(dynamic update_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [update_value$],
            {},
          );
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent!,
            [],
            {},
          );
      return target$.update(
        key,
        updateProxy,
        ifAbsent: ifAbsent == null ? null : ifAbsentProxy,
      );
    };
Function _MapBase_updateAll$(
  m.Scope scope$,
  MapBase target$,
) =>
    (m.FunctionPointer update) {
      dynamic updateProxy(
        dynamic update_key$,
        dynamic update_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [
              update_key$,
              update_value$,
            ],
            {},
          );
      target$.updateAll(updateProxy);
    };
Function _MapBase_map$(
  m.Scope scope$,
  MapBase target$,
) =>
    (m.FunctionPointer transform) {
      MapEntry transformProxy(
        dynamic transform_key$,
        dynamic transform_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            transform,
            [
              transform_key$,
              transform_value$,
            ],
            {},
          );
      return target$.map(transformProxy);
    };
Function _MapBase_addEntries$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.addEntries;
Function _MapBase_removeWhere$(
  m.Scope scope$,
  MapBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(
        dynamic test_key$,
        dynamic test_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [
              test_key$,
              test_value$,
            ],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _MapBase_containsKey$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.containsKey;
Function _MapBase_toString$<K, V>(
  m.Scope scope$,
  MapBase<K, V> target$,
) =>
    target$.toString;
Function _MapBase_mapToString$(m.Scope scope$) => MapBase.mapToString;
Function UnmodifiableMapBase_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnmodifiableMapBase<K, V>;
Function UnmodifiableMapBase_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnmodifiableMapBase<K, V>;
Function MapView_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MapView<K, V>;
Function MapView_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MapView<K, V>;
Function _MapView_isEmpty$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _MapView_isNotEmpty$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _MapView_length$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.length;
    };
Function _MapView_keys$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.keys;
    };
Function _MapView_values$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.values;
    };
Function _MapView_entries$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    () {
      return target$.entries;
    };
Function _MapView__$(m.Scope scope$) => (Map map) {
      return MapView(Map.from(map));
    };
Function _MapView_cast$<K, V, RK, RV>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.cast<RK, RV>;
Function _MapView_$index$$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    (Object? index) => target$[index];
Function _MapView_$index_set$$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    (
      K index,
      V other,
    ) =>
        target$[index] = other;
Function _MapView_addAll$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.addAll;
Function _MapView_clear$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.clear;
Function _MapView_putIfAbsent$(
  m.Scope scope$,
  MapView target$,
) =>
    (
      dynamic key,
      m.FunctionPointer ifAbsent,
    ) {
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent,
            [],
            {},
          );
      return target$.putIfAbsent(
        key,
        ifAbsentProxy,
      );
    };
Function _MapView_containsKey$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.containsKey;
Function _MapView_containsValue$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.containsValue;
Function _MapView_forEach$(
  m.Scope scope$,
  MapView target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(
        dynamic action_key$,
        dynamic action_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              action_key$,
              action_value$,
            ],
            {},
          );
      target$.forEach(actionProxy);
    };
Function _MapView_remove$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.remove;
Function _MapView_toString$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.toString;
Function _MapView_addEntries$<K, V>(
  m.Scope scope$,
  MapView<K, V> target$,
) =>
    target$.addEntries;
Function _MapView_map$(
  m.Scope scope$,
  MapView target$,
) =>
    (m.FunctionPointer transform) {
      MapEntry transformProxy(
        dynamic transform_key$,
        dynamic transform_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            transform,
            [
              transform_key$,
              transform_value$,
            ],
            {},
          );
      return target$.map(transformProxy);
    };
Function _MapView_update$(
  m.Scope scope$,
  MapView target$,
) =>
    (
      dynamic key,
      m.FunctionPointer update, {
      m.FunctionPointer? ifAbsent,
    }) {
      dynamic updateProxy(dynamic update_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [update_value$],
            {},
          );
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent!,
            [],
            {},
          );
      return target$.update(
        key,
        updateProxy,
        ifAbsent: ifAbsent == null ? null : ifAbsentProxy,
      );
    };
Function _MapView_updateAll$(
  m.Scope scope$,
  MapView target$,
) =>
    (m.FunctionPointer update) {
      dynamic updateProxy(
        dynamic update_key$,
        dynamic update_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [
              update_key$,
              update_value$,
            ],
            {},
          );
      target$.updateAll(updateProxy);
    };
Function _MapView_removeWhere$(
  m.Scope scope$,
  MapView target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(
        dynamic test_key$,
        dynamic test_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [
              test_key$,
              test_value$,
            ],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function UnmodifiableMapView_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnmodifiableMapView<K, V>;
Function UnmodifiableMapView_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnmodifiableMapView<K, V>;
Function _UnmodifiableMapView__$(m.Scope scope$) => (Map map) {
      return UnmodifiableMapView(Map.from(map));
    };
Function _UnmodifiableMapView_cast$<K, V, RK, RV>(
  m.Scope scope$,
  UnmodifiableMapView<K, V> target$,
) =>
    target$.cast<RK, RV>;
Function Queue_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Queue<E>;
Function Queue_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Queue<E>;
Function _Queue__$(m.Scope scope$) => () {
      return Queue();
    };
Function _Queue_from_$(m.Scope scope$) => Queue.from;
Function _Queue_of_$(m.Scope scope$) => Queue.of;
Function _Queue_castFrom$<S, T>(m.Scope scope$) => Queue.castFrom<S, T>;
Function _Queue_cast$<E, R>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.cast<R>;
Function _Queue_removeFirst$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.removeFirst;
Function _Queue_removeLast$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.removeLast;
Function _Queue_addFirst$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.addFirst;
Function _Queue_addLast$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.addLast;
Function _Queue_add$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.add;
Function _Queue_remove$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.remove;
Function _Queue_addAll$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.addAll;
Function _Queue_removeWhere$(
  m.Scope scope$,
  Queue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _Queue_retainWhere$(
  m.Scope scope$,
  Queue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _Queue_clear$<E>(
  m.Scope scope$,
  Queue<E> target$,
) =>
    target$.clear;
Function DoubleLinkedQueue_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DoubleLinkedQueue<E>;
Function DoubleLinkedQueue_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DoubleLinkedQueue<E>;
Function _DoubleLinkedQueue_length$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.length;
    };
Function _DoubleLinkedQueue_first$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.first;
    };
Function _DoubleLinkedQueue_last$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.last;
    };
Function _DoubleLinkedQueue_single$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.single;
    };
Function _DoubleLinkedQueue_isEmpty$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _DoubleLinkedQueue_iterator$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _DoubleLinkedQueue__$(m.Scope scope$) => () {
      return DoubleLinkedQueue();
    };
Function _DoubleLinkedQueue_from_$(m.Scope scope$) => DoubleLinkedQueue.from;
Function _DoubleLinkedQueue_of_$(m.Scope scope$) => DoubleLinkedQueue.of;
Function _DoubleLinkedQueue_cast$<E, R>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.cast<R>;
Function _DoubleLinkedQueue_addLast$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.addLast;
Function _DoubleLinkedQueue_addFirst$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.addFirst;
Function _DoubleLinkedQueue_add$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.add;
Function _DoubleLinkedQueue_addAll$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.addAll;
Function _DoubleLinkedQueue_removeLast$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.removeLast;
Function _DoubleLinkedQueue_removeFirst$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.removeFirst;
Function _DoubleLinkedQueue_remove$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.remove;
Function _DoubleLinkedQueue_removeWhere$(
  m.Scope scope$,
  DoubleLinkedQueue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _DoubleLinkedQueue_retainWhere$(
  m.Scope scope$,
  DoubleLinkedQueue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _DoubleLinkedQueue_firstEntry$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.firstEntry;
Function _DoubleLinkedQueue_lastEntry$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.lastEntry;
Function _DoubleLinkedQueue_clear$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.clear;
Function _DoubleLinkedQueue_forEachEntry$(
  m.Scope scope$,
  DoubleLinkedQueue target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(DoubleLinkedQueueEntry action_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [action_element$],
            {},
          );
      target$.forEachEntry(actionProxy);
    };
Function _DoubleLinkedQueue_toString$<E>(
  m.Scope scope$,
  DoubleLinkedQueue<E> target$,
) =>
    target$.toString;
Function ListQueue_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ListQueue<E>;
Function ListQueue_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ListQueue<E>;
Function _ListQueue_iterator$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _ListQueue_isEmpty$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _ListQueue_length$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.length;
    };
Function _ListQueue_first$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.first;
    };
Function _ListQueue_last$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.last;
    };
Function _ListQueue_single$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    () {
      return target$.single;
    };
Function _ListQueue__$(m.Scope scope$) => ([int? initialCapacity]) {
      if (initialCapacity == null) {
        return ListQueue();
      }
      return ListQueue(initialCapacity!);
    };
Function _ListQueue_from_$(m.Scope scope$) => ListQueue.from;
Function _ListQueue_of_$(m.Scope scope$) => ListQueue.of;
Function _ListQueue_cast$<E, R>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.cast<R>;
Function _ListQueue_forEach$(
  m.Scope scope$,
  ListQueue target$,
) =>
    (m.FunctionPointer f) {
      void fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      target$.forEach(fProxy);
    };
Function _ListQueue_elementAt$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.elementAt;
Function _ListQueue_toList$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.toList;
Function _ListQueue_add$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.add;
Function _ListQueue_addAll$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.addAll;
Function _ListQueue_remove$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.remove;
Function _ListQueue_removeWhere$(
  m.Scope scope$,
  ListQueue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _ListQueue_retainWhere$(
  m.Scope scope$,
  ListQueue target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _ListQueue_clear$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.clear;
Function _ListQueue_toString$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.toString;
Function _ListQueue_addLast$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.addLast;
Function _ListQueue_addFirst$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.addFirst;
Function _ListQueue_removeFirst$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.removeFirst;
Function _ListQueue_removeLast$<E>(
  m.Scope scope$,
  ListQueue<E> target$,
) =>
    target$.removeLast;
Function SetBase_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SetBase<E>;
Function SetBase_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SetBase<E>;
Function _SetBase_iterator$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _SetBase_length$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.length;
    };
Function _SetBase_isEmpty$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _SetBase_isNotEmpty$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _SetBase_single$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.single;
    };
Function _SetBase_first$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.first;
    };
Function _SetBase_last$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    () {
      return target$.last;
    };
Function _SetBase_add$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.add;
Function _SetBase_contains$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.contains;
Function _SetBase_lookup$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.lookup;
Function _SetBase_remove$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.remove;
Function _SetBase_toSet$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.toSet;
Function _SetBase_cast$<E, R>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.cast<R>;
Function _SetBase_followedBy$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.followedBy;
Function _SetBase_whereType$<E, T>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.whereType<T>;
Function _SetBase_clear$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.clear;
Function _SetBase_addAll$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.addAll;
Function _SetBase_removeAll$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.removeAll;
Function _SetBase_retainAll$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.retainAll;
Function _SetBase_removeWhere$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.removeWhere(testProxy);
    };
Function _SetBase_retainWhere$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      target$.retainWhere(testProxy);
    };
Function _SetBase_containsAll$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.containsAll;
Function _SetBase_union$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.union;
Function _SetBase_intersection$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.intersection;
Function _SetBase_difference$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.difference;
Function _SetBase_toList$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.toList;
Function _SetBase_map$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer f) {
      dynamic fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.map(fProxy);
    };
Function _SetBase_toString$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.toString;
Function _SetBase_where$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer f) {
      bool fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.where(fProxy);
    };
Function _SetBase_expand$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer f) {
      Iterable fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.expand(fProxy);
    };
Function _SetBase_forEach$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer f) {
      void fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      target$.forEach(fProxy);
    };
Function _SetBase_reduce$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer combine) {
      dynamic combineProxy(
        dynamic combine_value$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_value$,
              combine_element$,
            ],
            {},
          );
      return target$.reduce(combineProxy);
    };
Function _SetBase_fold$(
  m.Scope scope$,
  SetBase target$,
) =>
    (
      dynamic initialValue,
      m.FunctionPointer combine,
    ) {
      dynamic combineProxy(
        dynamic combine_previousValue$,
        dynamic combine_element$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              combine_previousValue$,
              combine_element$,
            ],
            {},
          );
      return target$.fold(
        initialValue,
        combineProxy,
      );
    };
Function _SetBase_every$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer f) {
      bool fProxy(dynamic f_element$) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [f_element$],
            {},
          );
      return target$.every(fProxy);
    };
Function _SetBase_join$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.join;
Function _SetBase_any$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_element$],
            {},
          );
      return target$.any(testProxy);
    };
Function _SetBase_take$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.take;
Function _SetBase_takeWhile$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      return target$.takeWhile(testProxy);
    };
Function _SetBase_skip$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.skip;
Function _SetBase_skipWhile$(
  m.Scope scope$,
  SetBase target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      return target$.skipWhile(testProxy);
    };
Function _SetBase_firstWhere$(
  m.Scope scope$,
  SetBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.firstWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _SetBase_lastWhere$(
  m.Scope scope$,
  SetBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.lastWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _SetBase_singleWhere$(
  m.Scope scope$,
  SetBase target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_value$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_value$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _SetBase_elementAt$<E>(
  m.Scope scope$,
  SetBase<E> target$,
) =>
    target$.elementAt;
Function _SetBase_setToString$(m.Scope scope$) => SetBase.setToString;
Function UnmodifiableSetView_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnmodifiableSetView<E>;
Function UnmodifiableSetView_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnmodifiableSetView<E>;
Function _UnmodifiableSetView_length$<E>(
  m.Scope scope$,
  UnmodifiableSetView<E> target$,
) =>
    () {
      return target$.length;
    };
Function _UnmodifiableSetView_iterator$<E>(
  m.Scope scope$,
  UnmodifiableSetView<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _UnmodifiableSetView__$(m.Scope scope$) => (Set source) {
      return UnmodifiableSetView(Set.from(source));
    };
Function _UnmodifiableSetView_contains$<E>(
  m.Scope scope$,
  UnmodifiableSetView<E> target$,
) =>
    target$.contains;
Function _UnmodifiableSetView_lookup$<E>(
  m.Scope scope$,
  UnmodifiableSetView<E> target$,
) =>
    target$.lookup;
Function _UnmodifiableSetView_toSet$<E>(
  m.Scope scope$,
  UnmodifiableSetView<E> target$,
) =>
    target$.toSet;
Function SplayTreeMap_as$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SplayTreeMap<K, V>;
Function SplayTreeMap_is$<K, V>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SplayTreeMap<K, V>;
Function _SplayTreeMap_isEmpty$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _SplayTreeMap_isNotEmpty$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _SplayTreeMap_length$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.length;
    };
Function _SplayTreeMap_keys$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.keys;
    };
Function _SplayTreeMap_values$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.values;
    };
Function _SplayTreeMap_entries$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    () {
      return target$.entries;
    };
Function _SplayTreeMap__$(m.Scope scope$) => ([
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeMap();
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeMap(compare == null ? null : compareProxy);
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeMap(
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeMap_from_$(m.Scope scope$) => (
      Map other, [
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeMap.from(Map.from(other));
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeMap.from(
          Map.from(other),
          compare == null ? null : compareProxy,
        );
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeMap.from(
        Map.from(other),
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeMap_of_$(m.Scope scope$) => (
      Map other, [
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeMap.of(Map.from(other));
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeMap.of(
          Map.from(other),
          compare == null ? null : compareProxy,
        );
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeMap.of(
        Map.from(other),
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeMap_fromIterable_$(m.Scope scope$) => (
      Iterable iterable, {
      m.FunctionPointer? key,
      m.FunctionPointer? value,
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    }) {
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      dynamic keyProxy(dynamic key_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            key!,
            [key_element$],
            {},
          );
      dynamic valueProxy(dynamic value_element$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_element$],
            {},
          );
      return SplayTreeMap.fromIterable(
        Iterable.castFrom(iterable),
        compare: compare == null ? null : compareProxy,
        isValidKey: isValidKey == null ? null : isValidKeyProxy,
        key: key == null ? null : keyProxy,
        value: value == null ? null : valueProxy,
      );
    };
Function _SplayTreeMap_fromIterables_$(m.Scope scope$) => (
      Iterable keys,
      Iterable values, [
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeMap.fromIterables(
          Iterable.castFrom(keys),
          Iterable.castFrom(values),
        );
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeMap.fromIterables(
          Iterable.castFrom(keys),
          Iterable.castFrom(values),
          compare == null ? null : compareProxy,
        );
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeMap.fromIterables(
        Iterable.castFrom(keys),
        Iterable.castFrom(values),
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeMap_$index$$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    (Object? index) => target$[index];
Function _SplayTreeMap_remove$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.remove;
Function _SplayTreeMap_$index_set$$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    (
      K index,
      V other,
    ) =>
        target$[index] = other;
Function _SplayTreeMap_putIfAbsent$(
  m.Scope scope$,
  SplayTreeMap target$,
) =>
    (
      dynamic key,
      m.FunctionPointer ifAbsent,
    ) {
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent,
            [],
            {},
          );
      return target$.putIfAbsent(
        key,
        ifAbsentProxy,
      );
    };
Function _SplayTreeMap_update$(
  m.Scope scope$,
  SplayTreeMap target$,
) =>
    (
      dynamic key,
      m.FunctionPointer update, {
      m.FunctionPointer? ifAbsent,
    }) {
      dynamic updateProxy(dynamic update_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [update_value$],
            {},
          );
      dynamic ifAbsentProxy() => scope$.engine.callFunctionPointer(
            scope$,
            ifAbsent!,
            [],
            {},
          );
      return target$.update(
        key,
        updateProxy,
        ifAbsent: ifAbsent == null ? null : ifAbsentProxy,
      );
    };
Function _SplayTreeMap_updateAll$(
  m.Scope scope$,
  SplayTreeMap target$,
) =>
    (m.FunctionPointer update) {
      dynamic updateProxy(
        dynamic update_key$,
        dynamic update_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            update,
            [
              update_key$,
              update_value$,
            ],
            {},
          );
      target$.updateAll(updateProxy);
    };
Function _SplayTreeMap_addAll$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.addAll;
Function _SplayTreeMap_forEach$(
  m.Scope scope$,
  SplayTreeMap target$,
) =>
    (m.FunctionPointer f) {
      void fProxy(
        dynamic f_key$,
        dynamic f_value$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            f,
            [
              f_key$,
              f_value$,
            ],
            {},
          );
      target$.forEach(fProxy);
    };
Function _SplayTreeMap_clear$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.clear;
Function _SplayTreeMap_containsKey$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.containsKey;
Function _SplayTreeMap_containsValue$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.containsValue;
Function _SplayTreeMap_firstKey$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.firstKey;
Function _SplayTreeMap_lastKey$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.lastKey;
Function _SplayTreeMap_lastKeyBefore$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.lastKeyBefore;
Function _SplayTreeMap_firstKeyAfter$<K, V>(
  m.Scope scope$,
  SplayTreeMap<K, V> target$,
) =>
    target$.firstKeyAfter;
Function SplayTreeSet_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SplayTreeSet<E>;
Function SplayTreeSet_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SplayTreeSet<E>;
Function _SplayTreeSet_iterator$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _SplayTreeSet_length$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.length;
    };
Function _SplayTreeSet_isEmpty$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.isEmpty;
    };
Function _SplayTreeSet_isNotEmpty$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.isNotEmpty;
    };
Function _SplayTreeSet_first$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.first;
    };
Function _SplayTreeSet_last$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.last;
    };
Function _SplayTreeSet_single$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    () {
      return target$.single;
    };
Function _SplayTreeSet__$(m.Scope scope$) => ([
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeSet();
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeSet(compare == null ? null : compareProxy);
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeSet(
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeSet_from_$(m.Scope scope$) => (
      Iterable elements, [
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeSet.from(Iterable.castFrom(elements));
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeSet.from(
          Iterable.castFrom(elements),
          compare == null ? null : compareProxy,
        );
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeSet.from(
        Iterable.castFrom(elements),
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeSet_of_$(m.Scope scope$) => (
      Iterable elements, [
      m.FunctionPointer? compare,
      m.FunctionPointer? isValidKey,
    ]) {
      if (compare == null && isValidKey == null) {
        return SplayTreeSet.of(Iterable.castFrom(elements));
      }
      int compareProxy(
        dynamic compare_key1$,
        dynamic compare_key2$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            compare!,
            [
              compare_key1$,
              compare_key2$,
            ],
            {},
          );
      if (isValidKey == null) {
        return SplayTreeSet.of(
          Iterable.castFrom(elements),
          compare == null ? null : compareProxy,
        );
      }
      bool isValidKeyProxy(dynamic isValidKey_potentialKey$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            isValidKey!,
            [isValidKey_potentialKey$],
            {},
          );
      return SplayTreeSet.of(
        Iterable.castFrom(elements),
        compare == null ? null : compareProxy,
        isValidKey == null ? null : isValidKeyProxy,
      );
    };
Function _SplayTreeSet_cast$<E, R>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.cast<R>;
Function _SplayTreeSet_contains$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.contains;
Function _SplayTreeSet_add$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.add;
Function _SplayTreeSet_remove$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.remove;
Function _SplayTreeSet_addAll$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.addAll;
Function _SplayTreeSet_removeAll$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.removeAll;
Function _SplayTreeSet_retainAll$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.retainAll;
Function _SplayTreeSet_lookup$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.lookup;
Function _SplayTreeSet_intersection$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.intersection;
Function _SplayTreeSet_difference$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.difference;
Function _SplayTreeSet_union$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.union;
Function _SplayTreeSet_clear$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.clear;
Function _SplayTreeSet_toSet$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.toSet;
Function _SplayTreeSet_toString$<E>(
  m.Scope scope$,
  SplayTreeSet<E> target$,
) =>
    target$.toString;
